<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>QML Vietnam</title>
    <link>https://example.com/</link>
      <atom:link href="https://example.com/index.xml" rel="self" type="application/rss+xml" />
    <description>QML Vietnam</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Tue, 14 Feb 2023 10:09:26 +0700</lastBuildDate>
    <image>
      <url>https://example.com/media/icon_hu03ccfb93536ffaa14d5c51dca71785c3_35563_512x512_fill_lanczos_center_3.png</url>
      <title>QML Vietnam</title>
      <link>https://example.com/</link>
    </image>
    
    <item>
      <title>Bài 8: Quantum Neural Network</title>
      <link>https://example.com/post/qnn/</link>
      <pubDate>Tue, 14 Feb 2023 10:09:26 +0700</pubDate>
      <guid>https://example.com/post/qnn/</guid>
      <description>&lt;h2 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Giới thiệu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Quantum Neural Network&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;giới-thiệu-a-name1a&#34;&gt;Giới thiệu &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;!-- - Why Quantum neural network (https://pennylane.ai/qml/glossary/quantum_neural_network.html, https://axon.cs.byu.edu/papers/ezhov.fdisis00.pdf) --&gt;
&lt;p&gt;Từ những năm 90s, các nhà khoa học đã nghiên cứu sự liên quan của các hiện tượng lượng tử (&lt;em&gt;quantum phenomena&lt;/em&gt;) với khả năng nhận thức của con người (&lt;a href=&#34;https://www.amazon.com/Shadows-Mind-Missing-Science-Consciousness/dp/0195106466&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Shadows of the Mind&amp;rdquo;, Roger Penrose, 1994&lt;/a&gt;). Do đó, sự xuất hiện của Quantum Neural Network (hay QNN) dường như là một bước phát triển mới trong việc mô phỏng hệ thống thần kinh của con người khi xử lý thông tin. Mặt khác, những mạng neuron thần kinh truyền thống (&lt;em&gt;classical neural networks&lt;/em&gt;) đang dần gặp khó khăn trong các ứng dụng dữ liệu lớn (&lt;em&gt;big data applications&lt;/em&gt;). Từ đó các đặc điểm của tính toán lượng tử như &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_parallelism&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;quantum parallelism&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_entanglement&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;entanglement&lt;/a&gt;, hay &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_interference&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;interference&lt;/a&gt; sẽ được tận dụng để cho ra mô hình hiệu quả hơn.&lt;/p&gt;
&lt;p&gt;Từ cuối thế kỷ trước, các nhà vật lý lượng tử đã cho ra &lt;em&gt;&amp;lsquo;quantum versions&amp;rsquo;&lt;/em&gt; của mạng neuron thần kinh truyền thống. Ở đó, các phép biến đổi (hay các gates) trong quantum circuit được tham số hóa. Do đó Quantum Neural Network thường được ám chỉ tới &lt;a href=&#34;https://arxiv.org/abs/1802.06002&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Parameterized Quantum Circuit&lt;/a&gt;. Ở bài viết này, mình sẽ giới thiệu tới mọi người những bước chính để xây dựng cũng như huấn luyện một mô hình QNN.&lt;/p&gt;
&lt;h2 id=&#34;quantum-neural-network-a-name2a&#34;&gt;Quantum Neural Network &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;!-- - General pipeline --&gt;
&lt;p&gt;Hầu hết các thiết kế hiện nay của QNN đều dựa theo một hệ thống &lt;em&gt;&amp;lsquo;hybrid&amp;rsquo;&lt;/em&gt; (mô tả ở &lt;strong&gt;Hình 1&lt;/strong&gt;) gồm 2 phần &amp;lsquo;quantum part&amp;rsquo; và &amp;lsquo;classical part&amp;rsquo;. Trong đó chúng ta sẽ xây dựng mô hình và trích xuất kết quả ở &amp;lsquo;quantum part&amp;rsquo;. Tuy nhiên tham số sẽ được tối ưu bởi những thuật toán ở &amp;lsquo;classical part&amp;rsquo; (ví dụ như &lt;a href=&#34;https://en.wikipedia.org/wiki/Gradient_descent&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gradient Descent&lt;/a&gt;, &lt;a href=&#34;https://viblo.asia/p/thuat-toan-toi-uu-adam-aWj53k8Q56m&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Adam&lt;/a&gt;, etc.).&lt;/p&gt;
















&lt;figure  id=&#34;figure-hình-1-hybrid-classical-quantum-systemhttpswwwmdpicom2079-9292113437&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 1: Hybrid classical-quantum system](https://www.mdpi.com/2079-9292/11/3/437)&#34; srcset=&#34;
               /post/qnn/hybrid_hu96260d1285b991b3aad9b0574cb6c075_16102_1ecc34cf5a405a492929a29085efc858.webp 400w,
               /post/qnn/hybrid_hu96260d1285b991b3aad9b0574cb6c075_16102_64adc6829910defe808854818cc8b9a9.webp 760w,
               /post/qnn/hybrid_hu96260d1285b991b3aad9b0574cb6c075_16102_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/qnn/hybrid_hu96260d1285b991b3aad9b0574cb6c075_16102_1ecc34cf5a405a492929a29085efc858.webp&#34;
               width=&#34;519&#34;
               height=&#34;373&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;https://www.mdpi.com/2079-9292/11/3/437&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hình 1: Hybrid classical-quantum system&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;!-- - Components of QNN
  + Data encoding
  + Variational layers
  + Decision function --&gt;
&lt;p&gt;Mô hình QNN thường có 3 bước chính (&lt;strong&gt;Hình 2&lt;/strong&gt;) như hầu hết bài toán mình đã trình bày ở các bài viết trước: &lt;em&gt;data encoder&lt;/em&gt;, &lt;em&gt;transformation&lt;/em&gt;, và &lt;em&gt;measurement&lt;/em&gt;. Sau đây mình sẽ đi chi tiết hơn vào từng bước một:
















&lt;figure  id=&#34;figure-hình-2-general-structure-of-qnnhttpswwwmdpicom2079-9292113437&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 2: General Structure of QNN](https://www.mdpi.com/2079-9292/11/3/437)&#34; srcset=&#34;
               /post/qnn/qdnn%20%281%29_hu9eb6d6170a05425057da6cfa9dd27266_28444_b45dcd273115b3eeccb23c3a06b7144e.webp 400w,
               /post/qnn/qdnn%20%281%29_hu9eb6d6170a05425057da6cfa9dd27266_28444_87fd33c9ec21b5a87b37aeef8276279f.webp 760w,
               /post/qnn/qdnn%20%281%29_hu9eb6d6170a05425057da6cfa9dd27266_28444_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/qnn/qdnn%20%281%29_hu9eb6d6170a05425057da6cfa9dd27266_28444_b45dcd273115b3eeccb23c3a06b7144e.webp&#34;
               width=&#34;759&#34;
               height=&#34;316&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;https://www.mdpi.com/2079-9292/11/3/437&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hình 2: General Structure of QNN&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Data Encoder:&lt;/strong&gt;
Cho $\vec{x} \in \mathbb{R}^n$, chúng ta sẽ mã hóa $\vec{x}$ dưới dạng một trạng thái lượng tử (&lt;em&gt;quantum state&lt;/em&gt;) $\ket{\psi(x)}$. Nếu như ở các bài viết trước mình đã nói về &lt;em&gt;Amplitude Encoding&lt;/em&gt; có thể mã hóa $\vec{x} \in \mathbb{R}^n$ với $\log{n}$ qubits, thì ở bài viết này mình sẽ giới thiệu một kỹ thuật khác: &lt;a href=&#34;https://docs.pennylane.ai/en/stable/code/api/pennylane.AngleEmbedding.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Angle Encoding&lt;/em&gt;&lt;/a&gt;. Ở đó mỗi thành phần $x_i$ của $\vec{x}$ là tham số của các rotation gates:

$$
\ket{\psi(x)} = R(x_1) \otimes R(x_2) \otimes ... \otimes R(x_n) \ket{\psi_0}
$$
&lt;br&gt;
Có thể thấy cách mã hóa này cần $n$ qubits cho $\vec{x} \in \mathbb{R}^n$, tuy nhiên với độ phức tạp nhỏ (gồm $n$ one-qubit rotation gates) [&lt;strong&gt;Box 1&lt;/strong&gt;] kỹ thuật này vẫn thường xuyên được sử dụng trong các mô hình QNN.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;Box 1:&lt;/strong&gt; Khi so sánh độ phức tạp của một thuật toán quantum, ta thường tính đến số lượng &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_logic_gate#Universal_quantum_gates&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;universal quantum gates&lt;/em&gt;&lt;/a&gt; được sử dụng. Với &lt;em&gt;Amplitude Encoding&lt;/em&gt; mặc dù có thể sự tối ưu về số lượng qubits được sử dụng (&amp;lsquo;qubit efficient&amp;rsquo;) nhưng lại cần $O(2^n)$ universal gates để thực hiện. Ngược lại, &lt;em&gt;Angle Encoding&lt;/em&gt; chỉ có độ phức tạp $O(n)$ nhưng cần tới $n$ qubits.
  &lt;/div&gt;
&lt;/div&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;Transformation&lt;/strong&gt;
Bước này đóng vai trò chính cho khả năng của một mô hình QNN. Ở đây các quantum gates sẽ được tham số hóa bởi $\omega \in \mathbb{R}^{n \times 3 \times l}$ như &lt;strong&gt;Hình 3&lt;/strong&gt; với $l$ là số layers của mô hình. Có thể thấy với mỗi layer sẽ gồm 2 thành phần: rotation and entanglement. Nếu như với rotation, chúng ta thực hiện phép quay $\ket{\psi(x)}$ xung quanh &lt;a href=&#34;https://en.wikipedia.org/wiki/Bloch_sphere&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bloch sphere&lt;/a&gt; để học những trạng thái khác nhau của data, thì entanglement sẽ tăng cường khả năng trao đổi thông tin của các qubits có trong $\ket{\psi(x)}$ từ đó giúp mô hình học được những hidden correlation của các features $x_i$ trong $\vec{x}$ (&lt;strong&gt;Box 2&lt;/strong&gt;).  &lt;br&gt;

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  &lt;figure  id=&#34;figure-hình-3-transformationhttpswwwmdpicom2079-9292113437&#34;&gt;
    &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
      &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 3: Transformation](https://www.mdpi.com/2079-9292/11/3/437)&#34; srcset=&#34;
                 /post/qnn/pqc_hu5db63afabc32ad892deff2516b206b0b_37698_1716bfa76128fed5cbc9d92835e9ee90.webp 400w,
                 /post/qnn/pqc_hu5db63afabc32ad892deff2516b206b0b_37698_205c9b5c1dddb3abc70b62a4010daf64.webp 760w,
                 /post/qnn/pqc_hu5db63afabc32ad892deff2516b206b0b_37698_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
                 src=&#34;https://example.com/post/qnn/pqc_hu5db63afabc32ad892deff2516b206b0b_37698_1716bfa76128fed5cbc9d92835e9ee90.webp&#34;
                 width=&#34;591&#34;
                 height=&#34;248&#34;
                 loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
    &lt;/div&gt;&lt;figcaption&gt;
        &lt;a href=&#34;https://www.mdpi.com/2079-9292/11/3/437&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hình 3: Transformation&lt;/a&gt;
      &lt;/figcaption&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
  &lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;Box 2:&lt;/strong&gt; Nếu các bạn đã tìm hiểu qua thì khi hai qubits được gọi là &amp;rsquo;entangled&amp;rsquo; với nhau thì mang tới tính chất: Nếu trạng thái của qubit này thay đổi thì sẽ ảnh hưởng tới trạng thái của qubit còn lại. Do đó với mỗi qubit có trong $\ket{\psi(x)}$ đang chứa thông tin của $x_i$ (theo &lt;em&gt;Angle Encoding&lt;/em&gt;), entanglement sẽ giúp tăng cường liên kết giữa các features của dữ liệu từ đó tăng khả năng dự đoán của mô hình. Đây cũng chính là đặc điểm mang tới sự vượt trội của QNN với classical NN.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Hiện tại có rất nhiều thiết kế mô hình &lt;em&gt;Transformation&lt;/em&gt; khác nhau, mọi người có thể xem qua bài báo &lt;a href=&#34;https://arxiv.org/pdf/1905.10876.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;này&lt;/a&gt; để tìm hiểu thêm.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;Measurement&lt;/strong&gt;
Ở đây, chúng ta sẽ trả lời câu hỏi làm sao có để trích xuất những features có ý nghĩa từ quantum state để mình có thể lấy ra output từ chúng. Có lẽ phương pháp measurement phổ biến nhất trong các mô hình QNN là tính giá trị trung bình của &lt;a href=&#34;https://en.wikipedia.org/wiki/Observable#:~:text=In%20physics%2C%20an%20observable%20is,Examples%20include%20position%20and%20momentum.&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;observables&lt;/a&gt;, Pauli-Z, của một quantum state.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ta có:

  $$
  Z = \left[ \begin{array}{cc} 1 &amp; 0 \\
  0 &amp; -1 \end{array} \right] = \ket{0}\bra{0} - \ket{1}\bra{1}
  $$
  &lt;/p&gt;
&lt;p&gt;$\Rightarrow$ Giá trị trung bình:

  $$
  \bra{\psi}Z\ket{\psi} = \bra{\psi}\ket{0}\bra{0}\ket{\psi} - \bra{\psi}\ket{1}\bra{1}\ket{\psi}
  $$
  

  $$
  = |\braket{0|\psi}|^2 - |\braket{1|\psi}|^2 = P(0) - P(1)
  $$
  
Có thể thấy khi ta lấy giá trị trung bình của observables $Z$ của quantum state $\ket{\psi}$ ta thu được một hiệu giữa xác suất output có giá trị bằng $0$, $P(0)$ và xác suất output có giá trị bằng $1$, $P(1)$.&lt;/p&gt;
&lt;p&gt;Trong bài toán phân loại, mô hình chúng ta sẽ được tối ưu về $1$ tương đương $P(0) = 1$ và $P(1) = 0$ nếu dư liệu đầu vào có nhãn là $0$. Và ngược lại, mô hình tối ưu về $-1$ tương đương $P(0) = 0$ và $P(1) = 1$ nếu dư liệu đầu vào có nhãn là $1$.&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;Tối ưu với quantum circuit:&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vậy làm sao chúng ta có thể tối ưu tham số trong một quantum circuit. Như mình đề cập ở trên, với mô hình hybrid quantum-classical, các tham số sẽ được tối ưu dựa vào thuật toán của &amp;lsquo;classical part&amp;rsquo;(&lt;strong&gt;Hình 1&lt;/strong&gt;) như Gradient Descent hay Adam, etc. Vậy câu hỏi đưa ra rằng liệu có sự khác biệt giữa cách tính &lt;strong&gt;gradient&lt;/strong&gt; của &amp;lsquo;&lt;em&gt;classical parameters&lt;/em&gt;&amp;rsquo; và &amp;lsquo;&lt;em&gt;quantum parameters&lt;/em&gt;&amp;rsquo;. Với mô hình NN truyền thống, nếu gradient của tham số được tính dựa theo &lt;a href=&#34;https://en.wikipedia.org/wiki/Chain_rule&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chain Rule&lt;/a&gt; thì với QNN, ta có kỹ thuật &lt;a href=&#34;https://pennylane.ai/qml/glossary/parameter_shift.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Paramter shift rule&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Với Paramter shift rule, gradient của tham số $\theta$ trong hàm $f(\theta)$ được tính bằng:

  $$
  \nabla_{\theta}f = r[f(\theta + s) - f(\theta + s)] 
  $$
  
Với $r$ và $s$ được chọn dựa trên cách ta xây dựng hàm $f$. Nếu các bạn muốn tìm hiểu sâu hơn thì có thể đọc bài báo &lt;a href=&#34;https://arxiv.org/abs/1811.11184&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;này&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;code-a-name3a&#34;&gt;Code &lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Mình đã đi qua đầy đủ các thành phần để xây dựng một thuật toán QNN, giờ chúng ta sẽ đi chi tiết hơn làm thế nào để triển khai một mô hình QNN với &lt;a href=&#34;https://pennylane.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pennylane&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;itertools&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datasets&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.utils&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shuffle&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.preprocessing&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minmax_scale&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.model_selection&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;train_test_split&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sklearn.metrics&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;metrics&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;pennylane&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;qml&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;pennylane&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numpy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;pennylane.templates.embeddings&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AngleEmbedding&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;pennylane.templates.layers&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StronglyEntanglingLayers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;pennylane.optimize&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GradientDescentOptimizer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# ---------------------------LOAD DATA------------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# load the dataset&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;iris&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;datasets&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;load_iris&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# shuffle the data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shuffle&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iris&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iris&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;random_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# select only 2 first classes from the data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# normalize data&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minmax_scale&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;feature_range&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# split data into train + validation and test&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X_train_val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X_test&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_train_val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_test&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;train_test_split&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# ------------------------------------DEFINE MODEL---------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# number of qubits is equal to the number of features&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;n_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# quantum device handle&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qml&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;device&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;default.qubit&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wires&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n_qubits&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# quantum circuit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nd&#34;&gt;@qml&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qnode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;weights&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;AngleEmbedding&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wires&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;StronglyEntanglingLayers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;weights&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wires&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n_qubits&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qml&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qml&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PauliZ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# variational quantum classifier&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;variational_classifier&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;weights&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;bias&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;weights&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bias&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cost&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expectations&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;e_predicted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variational_classifier&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;loss&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e_predicted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expectations&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loss&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# ------------------------------------TRAIN----------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# number of quantum layers&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;n_layers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# split into train and validation&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X_train&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X_validation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_train&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_validation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;train_test_split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X_train_val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_train_val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# convert classes to expectations : 0 to -1, 1 to +1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;e_train&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;empty_like&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_train&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;e_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y_train&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;e_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y_train&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# select learning batch size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;batch_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# calculate numbe of batches&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;batches&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;batch_size&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# select number of epochs&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;n_epochs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# draw random quantum node weights&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;theta_weights&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StronglyEntanglingLayers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n_layers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n_layers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n_wires&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;theta_bias&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;theta_init&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta_weights&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta_bias&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# initial weights&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# train the variational classifier&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta_init&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# start of main learning loop&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# build the optimizer object&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;pennylane_opt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GradientDescentOptimizer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# split training data into batches&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X_batches&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array_split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;arange&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X_train&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;batches&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;batch_index&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;enumerate&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chain&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n_epochs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X_batches&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]))):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# Update the weights by one optimizer step&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;batch_cost&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;lambda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cost&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X_train&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;batch_index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e_train&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;batch_index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pennylane_opt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;batch_cost&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# use X_validation and y_validation to decide whether to stop&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# end of learning loop&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# ----------------------------------------VALIDATION------------------------------------------&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# convert expectations to classes&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;expectations&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;array&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;([&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;variational_classifier&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;X_test&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;prob_class_zero&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expectations&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;2.0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;y_pred&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prob_class_zero&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;accuracy_score&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_test&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_pred&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;metrics&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;confusion_matrix&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_test&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y_pred&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Đầu tiên, với hàm &lt;code&gt;circuit()&lt;/code&gt; mình định nghĩa mô hình QNN của mình như sau:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Data Encoder: Như mình đề cập ở trên, mình sẽ sử dụng kỹ thuật &lt;code&gt;AngleEmbedding&lt;/code&gt;. Mọi người có thể dễ dàng import nó với pennylane: &lt;code&gt;pennylane.templates.embeddings.AngleEmbedding&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Transformation: Mình sử dụng mô hình như đã miêu tả ở &lt;strong&gt;Hình 3&lt;/strong&gt; với built-in function của pennylane là &lt;code&gt;pennylane.templates.layers.StronglyEntanglingLayers&lt;/code&gt; (chi tiết hơn ở &lt;a href=&#34;https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Measurement: Cuối cùng mình tính giá trị trung bình (expectation values) của Pauli-Z với &lt;code&gt;pennylane.expval()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Chạy chương trình trên mình có kết quả &lt;code&gt;accuracy_score=1.0&lt;/code&gt; và &lt;code&gt;confusion_matrix&lt;/code&gt;:&lt;/p&gt;
















&lt;figure  id=&#34;figure-hình-4-confusion-matrix&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 4: Confusion Matrix]()&#34; srcset=&#34;
               /post/qnn/result_hu2eee2778346ba8335926c6229b12536c_5798_260e66b76f61f431e47b36cd2423aa0f.webp 400w,
               /post/qnn/result_hu2eee2778346ba8335926c6229b12536c_5798_122681b893e2aa1a38955240590045cc.webp 760w,
               /post/qnn/result_hu2eee2778346ba8335926c6229b12536c_5798_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/qnn/result_hu2eee2778346ba8335926c6229b12536c_5798_260e66b76f61f431e47b36cd2423aa0f.webp&#34;
               width=&#34;306&#34;
               height=&#34;266&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;&#34;&gt;Hình 4: Confusion Matrix&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Chú ý rằng vì output của mô hình trong khoảng $[-1,1]$, nên khi thực hiện bước validation mình sẽ chuyển về $[0,1]$ nên ta mới có bước &lt;code&gt;prob_class_zero = ( expectations + 1.0) / 2.0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Mọi người có để download code ở &lt;a href=&#34;https://github.com/qmlvietnam/CodeforBlog/blob/main/QNN.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>January 2023</title>
      <link>https://example.com/newsletter/january-2023/</link>
      <pubDate>Mon, 13 Feb 2023 21:27:42 +0700</pubDate>
      <guid>https://example.com/newsletter/january-2023/</guid>
      <description>&lt;hr&gt;
&lt;!-- # News 📰

1. [Determinable and interpretable network representation for link prediction](https://www.nature.com/articles/s41598-022-21607-4)

2. [Azure Quantum Credits Program propels quantum innovation and exploration for researchers, educators, and students](https://cloudblogs.microsoft.com/quantum/2022/10/20/azure-quantum-credits-program-propels-quantum-innovation-and-exploration-for-researchers-educators-and-students/)

3. [Penn State researchers to explore using quantum computers to design new drugs](https://www.eurekalert.org/news-releases/969327)

4. [Multiverse Computing and Mila Join Forces to Advance Artificial Intelligence with Quantum Computing](https://www.einnews.com/pr_news/597582546/multiverse-computing-and-mila-join-forces-to-advance-artificial-intelligence-with-quantum-computing)

5. [Quantum AI Elon Musk Review / Scam App Or Legit?](https://www.tribuneindia.com/news/brand-connect/quantum-ai-elon-musk-review-scam-app-or-legit-444921) --&gt;
&lt;h1 id=&#34;videos-&#34;&gt;Videos 📽️&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=D7jvk2WEEBs&amp;amp;list=PL3wgeHwlaZxkChm7mL0v-y4PNVvQjMKKu&amp;amp;t=16s&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MIT iQuHACK 2023 workshop collection&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=Du_HfP0Crm8&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Osprey: The World&amp;rsquo;s Largest Quantum Computer&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;learning-resources-&#34;&gt;Learning Resources 🎓&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://careers.moodys.com/job/17660532/summer-internship-2023-quantum-computing-engineer-remote/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Summer Internship 2023– Quantum Computing Enginee&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://qc.ethz.ch/education/quantum-classes-at-eth-spring23.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Classes in Quantum Science and Technology at ETH&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;publications-&#34;&gt;Publications 📃&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://deepai.org/publication/asynchronous-training-of-quantum-reinforcement-learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Asynchronous training of quantum reinforcement learning&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-0&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;The development of quantum machine learning (QML) has received a lot of interest recently thanks to developments in both quantum computing (QC) and machine learning (ML). One of the ML paradigms that can be utilized to address challenging sequential decision-making issues is reinforcement learning (RL). It has been demonstrated that classical RL can successfully complete many difficult tasks. A leading method of building quantum RL agents relies on the variational quantum circuits (VQC). However, training QRL algorithms with VQCs requires significant amount of computational resources. This issue hurdles the exploration of various QRL applications. In this paper, we approach this challenge through asynchronous training QRL agents. Specifically, we choose the asynchronous training of advantage actor-critic variational quantum policies. We demonstrate the results via numerical simulations that within the tasks considered, the asynchronous training of QRL agents can reach performance comparable to or superior than classical agents with similar model sizes and architectures.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2301.13295&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Boltzmann Machines: Applications in Quantitative Finance&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-1&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;In this thesis we explore using the D-Wave Advantage 4.1 quantum annealer to sample from quantum Boltzmann distributions and train quantum Boltzmann machines (QBMs). We focus on the real-world problem of using QBMs as generative models to produce synthetic foreign exchange market data and analyze how the results stack up against classical models based on restricted Boltzmann machines (RBMs). Additionally, we study a small 12-qubit problem which we use to compare samples obtained from the Advantage 4.1 with theory, and in the process gain vital insights into how well the Advantage 4.1 can sample quantum Boltzmann random variables and be used to train QBMs. Through this, we are able to show that the Advantage 4.1 can sample classical Boltzmann random variables to some extent, but is limited in its ability to sample from quantum Boltzmann distributions. Our findings indicate that QBMs trained using the Advantage 4.1 are much noisier than those trained using simulations and struggle to perform at the same level as classical RBMs. However, there is the potential for QBMs to outperform classical RBMs if future generation annealers can generate samples closer to the desired theoretical distributions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2301.13169&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Improved machine learning algorithm for predicting ground state properties&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-2&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Finding the ground state of a quantum many-body system is a fundamental problem in quantum physics. In this work, we give a classical machine learning (ML) algorithm for predicting ground state properties with an inductive bias encoding geometric locality. The proposed ML model can efficiently predict ground state properties of an n-qubit gapped local Hamiltonian after learning from only O(log(n)) data about other Hamiltonians in the same quantum phase of matter. This improves substantially upon previous results that require O(n^c) data for a large constant c. Furthermore, the training and prediction time of the proposed ML model scale as O(nlogn) in the number of qubits n. Numerical experiments on physical systems with up to 45 qubits confirm the favorable scaling in&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2301.12707&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ensemble-learning variational shallow-circuit quantum classifiers&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-3&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Classification is one of the main applications of supervised learning. Recent advancement in developing quantum computers has opened a new possibility for machine learning on such machines. However, due to the noisy performance of near-term quantum computers, we desire an approach for solving classification problems with only shallow circuits. Here, we propose two ensemble-learning classification methods, namely bootstrap aggregating and adaptive boosting, which can significantly enhance the performance of variational quantum classifiers for both classical and quantum datasets. The idea is to combine several weak classifiers, each implemented on a shallow noisy quantum circuit, to make a strong one with high accuracy. While both of our protocols substantially outperform error-mitigated primitive classifiers, the adaptive boosting shows better performance than the bootstrap aggregating. In addition, its training error decays exponentially with the number of classifiers, leading to a favorable complexity for practical realization. The protocols have been exemplified for classical handwriting digits as well as quantum phase discrimination of a symmetry-protected topological Hamiltonian.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2301.12505&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Implementing a Hybrid Quantum-Classical Neural Network by Utilizing a Variational Quantum Circuit for Detection of Dementia&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-4&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Magnetic resonance imaging (MRI) is a common technique to scan brains for strokes, tumors, and other abnormalities that cause forms of dementia. However, correctly diagnosing forms of dementia from MRIs is difficult, as nearly 1 in 3 patients with Alzheimer&amp;rsquo;s were misdiagnosed in 2019, an issue neural networks can rectify. Quantum computing applications This proposed novel neural network architecture uses a fully-connected (FC) layer, which reduces the number of features to obtain an expectation value by implementing a variational quantum circuit (VQC). The VQC created in this study utilizes a layer of Hadamard gates, Rotation-Y gates that are parameterized by tanh(intensity) * (pi/2) of a pixel, controlled-not (CNOT) gates, and measurement operators to obtain the expected values. This study found that the proposed hybrid quantum-classical convolutional neural network (QCCNN) provided 97.5% and 95.1% testing and validation accuracies, respectively, which was considerably higher than the classical neural network (CNN) testing and validation accuracies of 91.5% and 89.2%. Additionally, using a testing set of 100 normal and 100 dementia MRI images, the QCCNN detected normal and demented images correctly 95% and 98% of the time, compared to the CNN accuracies of 89% and 91%. With hospitals like Massachusetts General Hospital beginning to adopt machine learning applications for biomedical image detection, this proposed architecture would approve accuracies and potentially save more lives. Furthermore, the proposed architecture is generally flexible, and can be used for transfer-learning tasks, saving time and resources.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>December 2022</title>
      <link>https://example.com/newsletter/december-2022/</link>
      <pubDate>Fri, 06 Jan 2023 20:09:00 +0700</pubDate>
      <guid>https://example.com/newsletter/december-2022/</guid>
      <description>&lt;h1 id=&#34;news-&#34;&gt;News 📰&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thequantuminsider.com/2022/12/30/hybrid-quantum-classical-algorithm-shows-promise-for-unraveling-the-protein-folding-problem/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hybrid Quantum-Classical Algorithm Shows Promise for Unraveling the Protein Folding Problem&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thequantuminsider.com/2022/12/01/qubit-pharmaceuticals-works-with-nvidia-to-create-hybrid-computing-platform-to-accelerate-drug-discovery-with-nvidia/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Qubit Pharmaceuticals Works With NVIDIA to Create Hybrid Computing Platform to Accelerate Drug Discovery with NVIDIA&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thequantuminsider.com/2022/12/07/ionq-and-hyundai-motors-expand-quantum-computing-partnership-continuing-pursuit-of-automotive-innovation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IonQ and Hyundai Motors Expand Quantum Computing Partnership, Continuing Pursuit of Automotive Innovation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;videos-&#34;&gt;Videos 📽️&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.youtube.com/playlist?list=PLnK6MrIqGXsJfcBdppW3CKJ858zR8P4eP&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction to Quantum Computing: From Layperson to Programmer in 30 Steps&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;publications-&#34;&gt;Publications 📃&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2301.01851&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Machine Learning: from physics to software engineering&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-0&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Quantum machine learning (QML) is a new, rapidly growing, and fascinating area of research where quantum information science and quantum technologies meet novel machine learning and artificial intelligent facilities. A comprehensive analysis of the main directions of current QML methods and approaches is performed in this review. The aim of our work is twofold. First, we show how classical machine learning approach can help improve the facilities of quantum computers and simulators available today. It is most important due to the modern noisy intermediate-scale quantum (NISQ) era of quantum technologies. In particular, the classical machine learning approach allows optimizing quantum hardware for achieving desired quantum states by implementing quantum devices. Second, we discuss how quantum algorithms and quantum computers may be useful for solving keystone classical machine learning tasks. Currently, quantum-inspired algorithms, which use a quantum approach to classical information processing, represent a powerful tool in software engineering for improving classical computation capacities. In this work, we discuss various quantum neural network capabilities that can be implemented in quantum-classical training algorithms for variational circuits. It is expected that quantum computers will be involved in routine machine learning procedures. In this sense, we are showing how it is essential to elucidate the speedup problem for random walks on arbitrary graphs, which are used in both classical and quantum algorithms. Quantum technologies enhanced by machine learning in fundamental and applied quantum physics, as well as quantum tomography and photonic quantum computing, are also covered.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2301.01597&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Demystify Problem-Dependent Power of Quantum Neural Networks on Multi-Class Classification&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-1&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Quantum neural networks (QNNs) have become an important tool for understanding the physical world, but their advantages and limitations are not fully understood. Some QNNs with specific encoding methods can be efficiently simulated by classical surrogates, while others with quantum memory may perform better than classical classifiers. Here we systematically investigate the problem-dependent power of quantum neural classifiers (QCs) on multi-class classification tasks. Through the analysis of expected risk, a measure that weighs the training loss and the generalization error of a classifier jointly, we identify two key findings: first, the training loss dominates the power rather than the generalization ability; second, QCs undergo a U-shaped risk curve, in contrast to the double-descent risk curve of deep neural classifiers. We also reveal the intrinsic connection between optimal QCs and the Helstrom bound and the equiangular tight frame. Using these findings, we propose a method that uses loss dynamics to probe whether a QC may be more effective than a classical classifier on a particular learning task. Numerical results demonstrate the effectiveness of our approach to explain the superiority of QCs over multilayer Perceptron on parity datasets and their limitations over convolutional neural networks on image datasets. Our work sheds light on the problem-dependent power of QNNs and offers a practical tool for evaluating their potential merit.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2212.14810&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;On Machine Learning Knowledge Representation In The Form Of Partially Unitary Operator. Knowledge Generalizing Operator&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-2&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;A new form of ML knowledge representation with high generalization power is developed and implemented numerically. Initial IN attributes and OUT class label are transformed into the corresponding Hilbert spaces by considering localized wavefunctions. A partially unitary operator optimally converting a state from IN Hilbert space into OUT Hilbert space is then built from an optimization problem of transferring maximal possible probability from IN to OUT, this leads to the formulation of a new algebraic problem. Constructed Knowledge Generalizing Operator U can be considered as a IN to OUT quantum channel; it is a partially unitary rectangular matrix of the dimension dim(OUT)×dim(IN) transforming operators as AOUT=UAINU†. Whereas only operator U projections squared are observable ⟨OUT|U|IN⟩2 (probabilities), the fundamental equation is formulated for the operator U itself. This is the reason of high generalizing power of the approach; the situation is the same as for the Schrödinger equation: we can only measure ψ2, but the equation is written for ψ itself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2212.14807&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Improving Convergence for Quantum Variational Classifiers using Weight Re-Mapping&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-3&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Constrained combinatorial optimization problems abound in industry, from portfolio optimization to logistics. One of the major roadblocks in solving these problems is the presence of non-trivial hard constraints which limit the valid search space. In some heuristic solvers, these are typically addressed by introducing certain Lagrange multipliers in the cost function, by relaxing them in some way, or worse yet, by generating many samples and only keeping valid ones, which leads to very expensive and inefficient searches. In this work, we encode arbitrary integer-valued equality constraints of the form Ax=b, directly into U(1) symmetric tensor networks (TNs) and leverage their applicability as quantum-inspired generative models to assist in the search of solutions to combinatorial optimization problems. This allows us to exploit the generalization capabilities of TN generative models while constraining them so that they only output valid samples. Our constrained TN generative model efficiently captures the constraints by reducing number of parameters and computational costs. We find that at tasks with constraints given by arbitrary equalities, symmetric Matrix Product States outperform their standard unconstrained counterparts at finding novel and better solutions to combinatorial optimization problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pubs.rsc.org/en/content/articlepdf/2022/cs/d2cs00203e?fbclid=IwAR2eE5dU82cOhsJbreGrpkdqXokbg0UpBSEFVt9q7fCloipeljnxb91UMQQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum machine learning for chemistry and physics&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-4&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;In recent years, quantum machine learning has seen a substantial increase in the use of variational quantum circuits (VQCs). VQCs are inspired by artificial neural networks, which achieve extraordinary performance in a wide range of AI tasks as massively parameterized function approximators. VQCs have already demonstrated promising results, for example, in generalization and the requirement for fewer parameters to train, by utilizing the more robust algorithmic toolbox available in quantum computing. A VQCs&amp;rsquo; trainable parameters or weights are usually used as angles in rotational gates and current gradient-based training methods do not account for that. We introduce weight re-mapping for VQCs, to unambiguously map the weights to an interval of length 2π, drawing inspiration from traditional ML, where data rescaling, or normalization techniques have demonstrated tremendous benefits in many circumstances. We employ a set of five functions and evaluate them on the Iris and Wine datasets using variational classifiers as an example. Our experiments show that weight re-mapping can improve convergence in all tested settings. Additionally, we were able to demonstrate that weight re-mapping increased test accuracy for the Wine dataset by 10% over using unmodified weights.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bài 7: Quantum Support Vector Machine</title>
      <link>https://example.com/post/qsvm/</link>
      <pubDate>Wed, 28 Dec 2022 15:11:21 +0700</pubDate>
      <guid>https://example.com/post/qsvm/</guid>
      <description>&lt;h2 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Giới thiệu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Quantum Support Vector Machine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;giới-thiệu-a-name1a&#34;&gt;Giới thiệu &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Support Vector Machine, hay thường được gọi là SVM, có lẽ là một trong những thuật toán học máy có giám sát phổ biến nhất. Về cơ bản, trong bài toán phân loại hai classes (&lt;em&gt;binary classification problem&lt;/em&gt;), chúng sẽ cần đi tìm một siêu phẳng phân chia chính xác hai classes đó. Tuy nhiên tồn tại rất nhiều mặt phẳng như vậy (Hình 1). Thuật toán SVM sẽ giúp chúng ta đi tìm mặt phẳng tối ưu nhất. Về chi tiết về SVM, bạn có thể tham khảo ở &lt;a href=&#34;https://machinelearningcoban.com/2017/04/09/smv/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;&lt;/p&gt;
















&lt;figure  id=&#34;figure-hình-1-sourcehttpsmachinelearningcobancom20170409smv&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 1: Source](https://machinelearningcoban.com/2017/04/09/smv/)&#34; srcset=&#34;
               /post/qsvm/svm1_hua66151d383e5395872923dd9b9836688_45095_fb0a70f5d3a3ff7c6363442dfaed8f11.webp 400w,
               /post/qsvm/svm1_hua66151d383e5395872923dd9b9836688_45095_cf3902f79fc599a2da0c672ad98e9de8.webp 760w,
               /post/qsvm/svm1_hua66151d383e5395872923dd9b9836688_45095_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/qsvm/svm1_hua66151d383e5395872923dd9b9836688_45095_fb0a70f5d3a3ff7c6363442dfaed8f11.webp&#34;
               width=&#34;760&#34;
               height=&#34;507&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;https://machinelearningcoban.com/2017/04/09/smv/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hình 1: Source&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Cho véc-tơ $x_i \in \mathcal{R}^{N}$ với nhãn $y_i = \{1,-1\}$ tương ứng, với $i = 1,&amp;hellip;,M$ và $M$ là số điểm dữ liệu cho trước. Từ đó thuật toán SVM sẽ tìm một mặt siêu phẳng sao khoảng cách giữa các đường biên của từng class tương ứng là lớn nhất, như Hình 2.&lt;/p&gt;
















&lt;figure  id=&#34;figure-hình-2&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;Hình 2&#34; srcset=&#34;
               /post/qsvm/svm2_huc015f6bb82c62f3c92474d6200730cf8_66259_15d716164309fdf52e91ac7951fea207.webp 400w,
               /post/qsvm/svm2_huc015f6bb82c62f3c92474d6200730cf8_66259_20b0a72be3e038255f5faa11cf25fd25.webp 760w,
               /post/qsvm/svm2_huc015f6bb82c62f3c92474d6200730cf8_66259_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/qsvm/svm2_huc015f6bb82c62f3c92474d6200730cf8_66259_15d716164309fdf52e91ac7951fea207.webp&#34;
               width=&#34;675&#34;
               height=&#34;498&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      Hình 2
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Giả sử mặt siêu phẳng được biểu diễn bằng một véc-tơ tham số $\overrightarrow{\theta} \in \mathcal{R}^n$ và $b$, thì mình có véc-tơ $\overrightarrow{x} \in \mathcal{R}^n$ nằm trên mặt siêu phẳng này sẽ được biểu diễn dưới dạng:

$$
\theta^{T}x - b = 0
$$

Từ đây, thuật toán SVM sẽ tìm $\overrightarrow{\theta}$ và $b$ sao cho khoảng cách $\frac{2}{||\theta ||_2}$ lớn nhất và tách riêng được hai đường biên theo:

$$
 \left\{ \begin{array}{rcl}
\theta^{T}x - b \geq 1 &amp; \forall y = 1 \\ \theta^{T}x - b \leq 1 &amp; \forall y = -1
\end{array}\right.
$$


$$
\longrightarrow y(\theta^{T}x - b) \geq 1 
$$

Như vậy, bài toán tối ưu của chúng ta sẽ được triển khai như sau:&lt;/p&gt;
&lt;p&gt;
$$
\min_{\theta} \frac{1}{2} \|\theta \|_2 \quad (1)
$$

sao cho

$$
 \quad y_i(\theta^{T}x_i - b) - 1 \geq 0; \forall i= \{1,2,...,M \}
$$

Đến đây chúng ta thường đơn giản hóa bài toán tối ưu này theo dạng &lt;a href=&#34;https://en.wikipedia.org/wiki/Support_vector_machine#Computing_the_SVM_classifier:~:text=the%20primal%20problem.-,Dual,-%5Bedit%5D&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;dual&lt;/em&gt;&lt;/a&gt; rồi áp dụng &lt;a href=&#34;https://en.wikipedia.org/wiki/Support_vector_machine#Computing_the_SVM_classifier:~:text=Kernel%20trick,-%5Bedit%5D&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;kernel method&lt;/em&gt;&lt;/a&gt; để giải. Tuy nhiên, cách trên lại dường như không thể áp dụng trên một thuật toán lượng tử vì độ phức tạp của chúng (mọi người có thể đọc rõ hơn về phần này ở &lt;a href=&#34;https://link.springer.com/book/10.1007/978-1-4842-6522-2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chapter 5 Santanu Pattanayak et.al.&lt;/a&gt;). Mặt khác, một dạng biến đổi khác được gọi là &lt;em&gt;least square SVM&lt;/em&gt; có thể giải quyết được vấn đề này trong máy tính lượng tử và từ đó phát triển lên thành thuật toán QSVM như hiện tại.&lt;/p&gt;
&lt;h2 id=&#34;quantum-support-vector-machine-a-name2a&#34;&gt;Quantum Support Vector Machine &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Khác với &lt;em&gt;dual form&lt;/em&gt; của SVM, dạng &lt;em&gt;least square SVM&lt;/em&gt; biến đổi ràng buộc $y_i(\theta^T x_i -b) \geq 1$ thành:

$$
y_i(\theta^T x_i -b) = 1-e_i
$$

trong đó sai số $e_i \geq 0$ với mỗi điểm dữ liệu tương ứng $(x_i, y_i)$. Ở dưới dạng biến đổi này, ngoài việc tìm min của $\frac{1}{2} ||\theta||_2$ như ở công thức (1), thì trong bài toán tối ưu, mình cũng cần giảm thiểu sai số, $e_i$. Do đó bài toán tối ưu mới của &lt;em&gt;least square SVM&lt;/em&gt; tương đương:&lt;/p&gt;
&lt;p&gt;
$$
\min_{\theta} \frac{1}{2} \|\theta \|_2 + \frac{\gamma}{2}\sum_{i=1}^{M} e_i^2 \quad (2)

$$

sao cho

$$
 y_i(\theta^{T}x_i - b) = 1 - e_i; \forall i= \{1,2,...,M \}; e_i \geq 0  \quad (*)
$$
&lt;/p&gt;
&lt;p&gt;Vì $y_i \in \{1, -1\}$, nên $y_i^2 = 1$, thay vào (*), ta có

$$
 y_i^2(\theta^{T}x_i - b) = y_i - y_ie_i
$$


$$
\Leftrightarrow \theta^{T}x_i - b = y_i - y_ie_i
$$


$$
\Leftrightarrow y_i - (\theta^{T}x_i - b) = y_ie_i
$$

Mà $y_i \in \{1, -1\}$, nên $y_ie_i = e_i$ hoặc $-e_i$. Do đó mình hoàn toàn xóa bỏ ràng buộc $e_i \geq 0$ trong (*) để có ràng buộc mới&lt;br&gt;

$$
 y_i - (\theta^{T}x_i - b) = e_i ; \forall i= \{1,2,...,M \} \quad (**)
$$
&lt;/p&gt;
&lt;p&gt;Từ đây để giải bài toán tối ưu trên, mình sử dụng phương pháp nhân tử Lagrange (&lt;a href=&#34;https://en.wikipedia.org/wiki/Lagrange_multiplier&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Lagrange multipliers&lt;/a&gt;):

$$
\min L(\theta, b, \alpha, e) = \frac{1}{2} \|\theta \|_2 + \frac{\gamma}{2}\sum_{i=1}^{M} e_i^2 - \sum_{i=1}^{M}\alpha_i[(\theta^Tx_i-b)-y_i+e_i] 
$$

trong đó $\alpha_i$ là các nhân tử Lagrange. Giải bài toàn tìm min trên ta được:

$$
 \left\{ \begin{array}{rcl}
\nabla_{\theta} L = 0 \\
\frac{\partial L}{\partial b} = 0 \\
\nabla_{e} L = 0 \\   
\frac{\partial L}{\partial \alpha_i} = 0
\end{array}\right.
$$


$$
\Leftrightarrow \left\{ \begin{array}{rcl}
\theta - \sum_{i=1}^{M}\alpha_ix_i = 0  \quad (3)\\
\sum_{i=1}^{M}\alpha_ix_i = 0  \quad (4)\\
\gamma e - \alpha = 0  \quad (5) \\   
(\theta^Tx_i-b)-y_i+e_i = 0  \quad (6)
\end{array}\right.
$$

Thay giá trị của $\theta$ và $e$ ở (3) và (5) vào (6), ta có:

$$
y_i = (\sum_{j=1}^{M}\alpha_jx_j)x_i-b - \alpha_i \gamma^{-1} \quad (7)
$$

Gọi $K$ mà một ma trận $M\times M$ với các phần tử $K_{ij} = x_i x_j$. Ta có thể biến đổi công thức (4) và (7) dưới dạng phương trình:

$$
\left[ \begin{array}{cc} 0 &amp; \mathbb{1}^T \\
\mathbb{1} &amp; K + \gamma^{-1} \end{array} \right] \left[ \begin{array}{c} -b \\ \alpha \end{array} \right] = \left[ \begin{array}{c} 0 \\ Y \end{array} \right]

$$

$Y$ là một ma trận cột với các phân tử tương ứng là nhãn $y_i$.&lt;/p&gt;
&lt;p&gt;Từ đây mình đẫ biến đổi bài toán SVM thành một dạng của phương trình $Ax = b$, do đó thuật toán HHL của &lt;a href=&#34;https://example.com/post/important-subroutine-3&#34;&gt;Bài 5&lt;/a&gt; sẽ được sử dụng để hoàn thành thuật toán QSVM của chúng ta.&lt;/p&gt;
&lt;h2 id=&#34;code-a-name3a&#34;&gt;Code &lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Với thuật toán QSVM, mình có thể triển khai nó một cách đơn giản với vài dòng code sử dụng &lt;a href=&#34;https://qiskit.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM&amp;rsquo;s Qiskit&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ở đây, mình sẽ dụng một bộ dư liệu thật của bài toán dư đoán ung thư vú (breast cancer). Để đơn giản hóa, mình sử dụng thuật toán PCA để giảm chiều dữ liệu về 2&lt;/p&gt;
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/qsvm/data_hu778a4288589a01661333e2e0127bae5b_9294_a15143a7b74293d674ce6689c8040819.webp 400w,
               /post/qsvm/data_hu778a4288589a01661333e2e0127bae5b_9294_07a839920a2d2a1b60b1a736a08480e9.webp 760w,
               /post/qsvm/data_hu778a4288589a01661333e2e0127bae5b_9294_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/qsvm/data_hu778a4288589a01661333e2e0127bae5b_9294_a15143a7b74293d674ce6689c8040819.webp&#34;
               width=&#34;380&#34;
               height=&#34;264&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;Bài toán QSVM có thể triển khai như sau:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Gọi các modules cần thiết&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;matplotlib.pyplot&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;plt&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;numpy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;np&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;qiskit&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BasicAer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;qiskit.circuit.library&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ZZFeatureMap&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;qiskit.aqua&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QuantumInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aqua_globals&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;qiskit.aqua.algorithms&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QSVM&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;qiskit.aqua.utils&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;split_dataset_to_data_and_labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_label_to_class_name&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Set seed cho chương trình&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10599&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;aqua_globals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random_seed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;seed&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Ở đây, mình sẽ sử dụng một mạch có sẵn từ qiskit, được gọi là ZZFeatureMap, để mã hóa dữ liệu&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;feature_map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ZZFeatureMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;feature_dimension&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;feature_dim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reps&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;entanglement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;linear&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Khởi tạo thuật toán QSVM&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;qsvm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QSVM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;feature_map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;training_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Chạy mô phỏng bằng qiskit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;backend&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BasicAer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;qasm_simulator&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;quantum_instance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QuantumInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shots&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;seed_simulator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;seed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;seed_transpiler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;seed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qsvm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quantum_instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Testing success ratio: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;testing_accuracy&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Testing&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;success&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ratio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.85&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Chạy chương trình trên, thuật toán QSVM mang cho chúng ta độ chính xác là 85%.&lt;/p&gt;
&lt;p&gt;Source code cho phần này có thể được tìm thấy ở &lt;a href=&#34;https://github.com/qmlvietnam/CodeforBlog/blob/main/QSVM.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Để chứng thực kết quả trên, mình so sánh với thuật toán SVM của thư viện &lt;a href=&#34;https://scikit-learn.org/stable/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;&lt;strong&gt;sklearn&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;qiskit.aqua.algorithms&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SklearnSVM&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SklearnSVM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;Testing success ratio: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;testing_accuracy&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Testing&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;success&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ratio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.85&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Có thể thấy thuật toán QSVM mang lại kết quả có độ tính xác tương đương với SVM thông thường. Tuy nhiên, đây là kết quả từ một thí nghiệm mô phỏng và không có nhiễu (&lt;em&gt;noiseless environment&lt;/em&gt;). Trên thực tế, kết quả có thể bị ảnh hưởng bởi những tác động từ nhiễu trong máy tính lượng tử.&lt;/p&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Bài 6: Quantum Principal Component Analysis</title>
      <link>https://example.com/post/qpca/</link>
      <pubDate>Mon, 19 Dec 2022 13:51:26 +0700</pubDate>
      <guid>https://example.com/post/qpca/</guid>
      <description>&lt;h1 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Giới thiệu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Quantum PCA&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;giới-thiệu-a-name1a&#34;&gt;Giới thiệu &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Thuật toán &lt;a href=&#34;https://en.wikipedia.org/wiki/Principal_component_analysis&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Principal Component Analysis&lt;/a&gt; (hay PCA) là một trong những kỹ thuật quan trọng trong Machine Learning để giảm chiều dữ liệu (Dimensionality Reduction). Thông thường &lt;em&gt;data&lt;/em&gt; hay các &lt;em&gt;feature vectors&lt;/em&gt; được biểu diễn trên không gian đa chiều, thậm chí số chiều có thể lên tới vài nghìn. Việc tính toán cũng như lưu trữ trên bộ dữ liệu như vậy sẽ gặp rất nhiều khó khăn. Do đó, việc giảm chiều dữ liệu là một bước quan trọng trong nhiều bài toán, và điển hình ở đây mình sẽ đề cập tới thuật toán PCA.&lt;/p&gt;
&lt;p&gt;Thuật toán PCA được phát triển dựa theo mô hình tuyến tính để giữ lại $\mathcal{K}$ phần tử quan trọng nhất sao cho $\mathcal{K} &amp;lt; \mathcal{D}$ (số chiều của dữ liệu). Trong đó, tầm quan trọng của các phần tử được đánh giá dựa trên giá trị riêng (&lt;em&gt;eigenvalues&lt;/em&gt;) của ma trận phương sai (&lt;em&gt;covariance matrix&lt;/em&gt;) của dữ liệu. Nhưng với các bộ dữ liệu lớn, việc tính toán ma trận phương sai hay phân rã trị riêng cũng là một thách thức. Thực tế, với một bộ dữ liệu gồm $\mathcal{N}$ véc-tơ và mỗi véc-tơ được biển diễn trên không gian $\mathcal{D}$ chiều thì ta cần $O(\mathcal{D}^2\mathcal{N})$ để tính ma trận phương sai và $O(\mathcal{D}^3)$ cho việc phân rã trị riêng. Như vậy, độ phức tạp của thuật toán PCA sẽ là $O(\mathcal{D}^2\mathcal{N}+\mathcal{D}^3)$.&lt;/p&gt;
&lt;p&gt;Trong bài viết này, mình sẽ giới thiệu một phương pháp lượng tử để giải quyết bài toán trên với độ phức tạp $O(\mathcal{D}poly(\log{\mathcal{D}}))$ nhờ vào khả năng tính toán vượt trội của máy tính lượng tử: &lt;em&gt;&lt;a href=&#34;https://www.nature.com/articles/nphys3029&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Principal Component Analysis&lt;/a&gt;&lt;/em&gt; (hay qPCA).&lt;/p&gt;
&lt;h1 id=&#34;quantum-pca-a-name2a&#34;&gt;Quantum PCA &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Xét tập dữ liệu $\mathbb{X}$ gồm $\mathcal{N}$ véc-tơ. Giống với thuật toán PCA thông thường, qPCA cũng có bước chuẩn hóa dữ liệu sao cho kỳ vọng của dữ liệu là 0:&lt;/p&gt;

$$
x_i \rightarrow \frac{x_i - \frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}}x_i}{||x_i||_2} .
$$

&lt;p&gt;Từ đây ta hoàn toàn có thể biểu diễn dữ liệu trong máy tính lượng tử sử dụng phương pháp &lt;em&gt;Amplitude Embedding&lt;/em&gt; như mình đã đề cập ở &lt;a href=&#34;https://example.com/post/example-1&#34;&gt;Bài 2&lt;/a&gt;:&lt;/p&gt;

$$
\ket{x_i} = \sum_{k=0}^{\mathcal{D}-1}x_{ik}\ket{k}.
$$

&lt;p&gt;Giả sử ta gọi $\rho_i = \ket{x_i}\bra{x_i}$ là &lt;em&gt;outer product&lt;/em&gt; của véc-tơ $\ket{x_i}$.

$$
\rho_i = \sum_{k=0}^{\mathcal{D}-1}\sum_{m=0}^{\mathcal{D}-1}x_{ik}x_{im}\ket{k}\bra{m},
$$

Do đó ta xét trên toàn bộ tập dữ liệu $\mathcal{N}$ véc-tơ, ta có:

$$
\rho = \frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}}\rho_i = \frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}}\sum_{k=0}^{\mathcal{D}-1}\sum_{m=0}^{\mathcal{D}-1}x_{ik}x_{im}\ket{k}\bra{m},
$$
&lt;/p&gt;
&lt;p&gt;Như mọi người có thể thấy thì &lt;em&gt;amplitude&lt;/em&gt; của $\rho$ chính là các phần tử tương ứng của ma trận hiệp phương sai tại vị trí $(k,m)$.&lt;/p&gt;
&lt;p&gt;Như vậy việc còn lại của chúng ta cần phải làm là tìm các trị riêng và véc-tơ riêng tương ứng của $\rho$. Từ đó, bài toán đưa ta tới với thuật toán &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Phase Estimation&lt;/a&gt;&lt;/em&gt; (hay QPE), như mình để cập ở &lt;a href=&#34;https://example.com/post/important-subroutine-2/&#34;&gt;Bài 4&lt;/a&gt;. Trong thuật toán QPE, cho một ma trận đơn nhất $U$ và một trong những véc-tơ riêng của nó thì ta luôn tính được giá trị riêng tương ứng của véc-tơ đó. Tuy nhiên, $\rho$ không là ma trận đơn nhất (&lt;em&gt;unitary matrix&lt;/em&gt;), nên mình cần dùng một kỹ thuật khác để biến đổi: $\rho \longrightarrow U$. Vì $\rho$ là một ma trận Hermitian (chứng mính ở &lt;strong&gt;Box 1&lt;/strong&gt;), giống nhưng cách ở &lt;a href=&#34;https://example.com/post/important-subroutine-3/&#34;&gt;Bài 5&lt;/a&gt;, mình có thể chọn ma trận đơn nhất $U = e^{i\rho t}$.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Box 1:&lt;/strong&gt; Ma trận $H$ được gọi là Hermitian nếu $H = H^{\dagger}$.
Ta có:&lt;/p&gt;
&lt;p&gt;$$
\rho = \frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}}\sum_{k=0}^{\mathcal{D}-1}\sum_{m=0}^{\mathcal{D}-1}x_{ik}x_{im}\ket{k}\bra{m},
$$&lt;/p&gt;
&lt;p&gt;Dễ thấy $\rho$ đối xứng, và:&lt;/p&gt;
&lt;p&gt;$$
\rho^{\dagger} = \frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}}\sum_{k=0}^{\mathcal{D}-1}\sum_{m=0}^{\mathcal{D}-1}x_{ik}^{*}x_{im}^{*}\ket{k}\bra{m}
$$&lt;/p&gt;
&lt;p&gt;Trong đó, $x_{ik}^{*}$ là số liên hợp của $x_{ik}$. Tuy nhiên, ở đây ta xét véc-tơ $\overrightarrow{x} \in R$ nên $x_{ik}^{*} = x_{ik}$. Do đó, $\rho = \rho^{\dagger}$&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Xét ma trận Hermitian $\rho = \sum_{j} \lambda_j \ket{\phi_j}\bra{\phi_j}$ (theo phân tích phổ - &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Spectral_theorem&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;spectral decomposition&lt;/a&gt;&lt;/em&gt;), trong đó $\ket{\phi_j}$ và $\lambda_j$ là véc-tơ riêng và giá trị riêng tương ứng của $\rho$, ta có:

$$
U = e^{i\rho t} = \sum_{j} e^{i\lambda_j t} \ket{\phi_j}\bra{\phi_j} = \sum_{j} e^{2\pi i\frac{\lambda_j t}{2\pi}} \ket{\phi_j}\bra{\phi_j} 
$$

Mình đặt $\tilde{\lambda_j} = \frac{\lambda_j t}{2\pi}$, thì bài toán sẽ được đưa về khuôn mẫu của thuật toán QPE. Tuy nhiên thuật toán QPE yêu cầu ta biết trước véc-tơ riêng $\ket{\phi_j}$ nên thay vào đó ta có thể dùng một điểm dữ liệu bất kỳ $x_i=\sum_{j} \alpha_{ij} \ket{\phi_j}$, trong đó $\alpha_{ij} = \left\langle \phi_j \vert x_i \right\rangle$. Do đó ta có thể biểu diễn thuật toán QPE như sau:

$$
\text{QPE:} \ket{0}^{\otimes n} \ket{x_i} \rightarrow \sum_{j}^{\mathcal{D}} \alpha_{ij} \ket{\tilde{\lambda_j}} \ket{\phi_j}
$$
&lt;br&gt;
Không mất tính tông quát, ta thay $\ket{x_i}$ bằng $\ket{x_i}\bra{x_i}$, ta được:

$$
\text{QPE:} \ket{0}^{\otimes n} \otimes \rho_i \rightarrow \sum_{j}^{\mathcal{D}} |\alpha_{ij}|^2 \ket{\tilde{\lambda_j}}\bra{\tilde{\lambda_j}} \otimes \ket{\phi_j}\bra{\phi_j} 
$$
&lt;br&gt;
hay,

$$
\text{QPE:} \ket{0}^{\otimes n} \otimes \rho \rightarrow \frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}} \sum_{j}^{\mathcal{D}} |\alpha_{ij}|^2 \ket{\tilde{\lambda_j}}\bra{\tilde{\lambda_j}} \otimes \ket{\phi_j}\bra{\phi_j}. 
$$
&lt;/p&gt;
&lt;p&gt;Mặt khác, ta có:

$$
\frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}} |\alpha_{ij}|^2 = \frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}} \left\langle \phi_j \vert x_i \right\rangle \left\langle x_i \vert \phi_j \right\rangle
$$


$$
 = \bra{\phi_j} (\frac{1}{\mathcal{N}}\sum_{i=1}^{\mathcal{N}} \ket{x_i}\bra{x_i}) \ket{\phi_j} = \bra{\phi_j} \rho \ket{\phi_j}.
$$

Mà $\ket{\phi_j}$ là véc-tơ riêng của $\rho$ nên ta luôn có $\bra{\phi_j} \rho \ket{\phi_j} = \tilde{\lambda_j} \left\langle \phi_j \vert \phi_j \right\rangle = \tilde{\lambda_j}$.
Thay vào kết quả trên ta được:

$$
\text{QPE:} \ket{0}^{\otimes n} \otimes \rho \rightarrow \sum_{j}^{\mathcal{D}} \tilde{\lambda_j}\ket{\tilde{\lambda_j}}\bra{\tilde{\lambda_j}} \otimes \ket{\phi_j}\bra{\phi_j}. 
$$

Như vậy, thông qua phép đo của kết quả từ thuật toán QPE trên ta sẽ thu được véc-tơ riêng và giá trị riêng của ma trận hiệp phương sai $\rho$.&lt;/p&gt;
&lt;p&gt;Giờ chúng ta hãy đi kỹ hơn vào độ phức tạp của thuật toán qPCA.&lt;/p&gt;
&lt;p&gt;(1) Đầu tiên, ta cần độ phức tạp $O(\log{\mathcal{D}})$ để có được ma trận hiệp phương sai $\rho$, vì với &lt;em&gt;Amplitude Embedding&lt;/em&gt; ta cần $\log{\mathcal{D}}$ qubits để mã hóa véc-tơ $\ket{x_i}$&lt;/p&gt;
&lt;p&gt;(2) Với thuật toán tìm giá trị riêng và véc-tơ riêng - QPE, ta cần độ phức tạp $O(poly(\log{\mathcal{D}}))$ (như mình đã trình bày ở &lt;a href=&#34;https://example.com/post/important-subroutine-2/&#34;&gt;Bài 4&lt;/a&gt;) để thu được một cặp $(\lambda_j, \phi_j)$. Tuy nhiên bài toán yêu cầu ta tìm được $\mathcal{T}$ cặp có giá trị riêng lớn nhất, do đó trong trường hợp ma trận &lt;em&gt;full rank&lt;/em&gt; $\rho$, độ phức tạp bài toán lên tới $O(\mathcal{D}poly(\log{\mathcal{D}}))$.&lt;/p&gt;
&lt;p&gt;Từ (1) và (2), thuật toán qPCA sẽ có độ phức tạp $O(\mathcal{D}poly(\log{\mathcal{D}}))$. Nếu so với sánh với thuật toán PCA trên máy tính truyền thống có độ phức tạp $O(\mathcal{D}^2\mathcal{N}+\mathcal{D}^3)$, ta thấy rằng qPCA mang lại sự cải thiện đáng kể trong việc tính toán cũng như tối ưu được tài nguyên sử dụng đặc biệt trong các bài toán yêu cầu số chiều của dữ liệu lớn.&lt;/p&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>November 2022</title>
      <link>https://example.com/newsletter/november-2022/</link>
      <pubDate>Sat, 10 Dec 2022 19:53:10 +0700</pubDate>
      <guid>https://example.com/newsletter/november-2022/</guid>
      <description>&lt;h1 id=&#34;news-&#34;&gt;News 📰&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thequantuminsider.com/2022/11/14/d-wave-says-revenue-up-added-more-commercial-customers-in-q3/?fbclid=IwAR2pnBlITY1DxKAgtEpiceJFW5LJXH6uUrWY30w7UqGgc_iiH-Q5EOx9SVY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;D-Wave Says Revenue Up, Added More Commercial Customers in Q3&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thequantuminsider.com/2022/12/07/ionq-and-hyundai-motors-expand-quantum-computing-partnership-continuing-pursuit-of-automotive-innovation/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IonQ and Hyundai Motors Expand Quantum Computing Partnership, Continuing Pursuit of Automotive Innovation&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thequantuminsider.com/2022/11/28/qnlp-at-the-beeb-quantinuum-bbc-join-consortium-to-explore-real-world-uses-for-quantum-natural-language-processing/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;QNLP at The Beeb — Quantinuum, BBC Join Consortium to Explore Real-World Uses for Quantum Natural Language Processing&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://thequantuminsider.com/2022/11/21/unilevers-head-of-rd-alberto-prado-talks-quantum-at-iot-world-the-ai-summit-austin/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Unilever’s Head of R&amp;amp;D Alberto Prado Talks Quantum at IoT World &amp;amp; The AI Summit Austin&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;hackathon-and-internship-&#34;&gt;Hackathon and Internship 🎓&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://app.smarterselect.com/programs/85950-Los-Alamos-National-Laboratory?fbclid=IwAR1CBVL0qG50vll6OPTyWwfzPdVjJtnqVL2_IU5hOMz7nLLyChXxoTRoksQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2023 Quantum Computing Summer School Fellowship provided by Los Alamos National Laboratory&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zapatacomputing.com/interns/?fbclid=IwAR0X8Gs_6e4sE_AfX8HJ6ry507b5FkzK3Zxq8wMvZsaz3ZQXgjzrA4flyqo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2023 Zapata Quantum Computing Internship&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://research.ibm.com/blog/2023-quantum-internships?fbclid=IwAR1z2GdQhqcXCVtfZI71ZfMby3W1o8-hXU7-Fz5K1n8BxQlxM-e6ge4nJcs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2023 IBM Quantum Summer Internship&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://chicagoquantum.org/education-and-training/internships?fbclid=IwAR3NjGc_ppUCMQUXeEEKcEXmco2fFtC4imqEs6uJvMKlCiESYVPLHVoAsWU&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chicago Quantum Exchange Intership&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;publications-&#34;&gt;Publications 📃&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2211.02612?fbclid=IwAR0_N0EU9wBoo4g8JTg-IqF_3JGQy81NXN7ndtTak-cK2ENs_m0NCupsU5Q&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Reservoir Computing via Quantum Recurrent Neural Networks&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-0&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Recent developments in quantum computing and machine learning have propelled the interdisciplinary study of quantum machine learning. Sequential modeling is an important task with high scientific and commercial value. Existing VQC or QNN-based methods require significant computational resources to perform the gradient-based optimization of a larger number of quantum circuit parameters. The major drawback is that such quantum gradient calculation requires a large amount of circuit evaluation, posing challenges in current near-term quantum hardware and simulation software. In this work, we approach sequential modeling by applying a reservoir computing (RC) framework to quantum recurrent neural networks (QRNN-RC) that are based on classical RNN, LSTM and GRU. The main idea to this RC approach is that the QRNN with randomly initialized weights is treated as a dynamical system and only the final classical linear layer is trained. Our numerical simulations show that the QRNN-RC can reach results comparable to fully trained QRNN models for several function approximation and time series prediction tasks. Since the QRNN training complexity is significantly reduced, the proposed model trains notably faster. In this work we also compare to corresponding classical RNN-based RC implementations and show that the quantum version learns faster by requiring fewer training epochs in most cases. Our results demonstrate a new possibility to utilize quantum neural network for sequential modeling with greater quantum hardware efficiency, an important design consideration for noisy intermediate-scale quantum (NISQ) computers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2211.12681?fbclid=IwAR0a9WtjG-YpnlU-iEaOUD5Z1JWM2vcgbbtu7qrAljz0Ob2J8fRksny0XF0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Benchmarking Adversarially Robust Quantum Machine Learning at Scale&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-1&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Machine learning (ML) methods such as artificial neural networks are rapidly becoming ubiquitous in modern science, technology and industry. Despite their accuracy and sophistication, neural networks can be easily fooled by carefully designed malicious inputs known as adversarial attacks. While such vulnerabilities remain a serious challenge for classical neural networks, the extent of their existence is not fully understood in the quantum ML setting. In this work, we benchmark the robustness of quantum ML networks, such as quantum variational classifiers (QVC), at scale by performing rigorous training for both simple and complex image datasets and through a variety of high-end adversarial attacks. Our results show that QVCs offer a notably enhanced robustness against classical adversarial attacks by learning features which are not detected by the classical neural networks, indicating a possible quantum advantage for ML tasks. Contrarily, and remarkably, the converse is not true, with attacks on quantum networks also capable of deceiving classical neural networks. By combining quantum and classical network outcomes, we propose a novel adversarial attack detection technology. Traditionally quantum advantage in ML systems has been sought through increased accuracy or algorithmic speed-up, but our work has revealed the potential for a new kind of quantum advantage through superior robustness of ML models, whose practical realisation will address serious security concerns and reliability issues of ML algorithms employed in a myriad of applications including autonomous vehicles, cybersecurity, and surveillance robotic systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2211.16337?fbclid=IwAR39YeVFgOxIbHM2w4zSZDSq49JPQkpb7LepS7r8hsvqyrNyuehI5ilSSD4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Feature Maps for Graph Machine Learning on a Neutral Atom Quantum Processor&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-2&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Using a quantum processor to embed and process classical data enables the generation of correlations between variables that are inefficient to represent through classical computation. A fundamental question is whether these correlations could be harnessed to enhance learning performances on real datasets. Here, we report the use of a neutral atom quantum processor comprising up to 32 qubits to implement machine learning tasks on graph-structured data. To that end, we introduce a quantum feature map to encode the information about graphs in the parameters of a tunable Hamiltonian acting on an array of qubits. Using this tool, we first show that interactions in the quantum system can be used to distinguish non-isomorphic graphs that are locally equivalent. We then realize a toxicity screening experiment, consisting of a binary classification protocol on a biochemistry dataset comprising 286 molecules of sizes ranging from 2 to 32 nodes, and obtain results which are comparable to those using the best classical kernels. Using techniques to compare the geometry of the feature spaces associated with kernel methods, we then show evidence that the quantum feature map perceives data in an original way, which is hard to replicate using classical kernels.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2211.09121?fbclid=IwAR11axzJZbhtsl311J4b_ek3vx4XflJxBrXClDDbLCl6fsjCWdwSxXuvoqo&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Symmetric Tensor Networks for Generative Modeling and Constrained Combinatorial Optimization&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-3&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Constrained combinatorial optimization problems abound in industry, from portfolio optimization to logistics. One of the major roadblocks in solving these problems is the presence of non-trivial hard constraints which limit the valid search space. In some heuristic solvers, these are typically addressed by introducing certain Lagrange multipliers in the cost function, by relaxing them in some way, or worse yet, by generating many samples and only keeping valid ones, which leads to very expensive and inefficient searches. In this work, we encode arbitrary integer-valued equality constraints of the form Ax=b, directly into U(1) symmetric tensor networks (TNs) and leverage their applicability as quantum-inspired generative models to assist in the search of solutions to combinatorial optimization problems. This allows us to exploit the generalization capabilities of TN generative models while constraining them so that they only output valid samples. Our constrained TN generative model efficiently captures the constraints by reducing number of parameters and computational costs. We find that at tasks with constraints given by arbitrary equalities, symmetric Matrix Product States outperform their standard unconstrained counterparts at finding novel and better solutions to combinatorial optimization problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://pubs.rsc.org/en/content/articlepdf/2022/cs/d2cs00203e?fbclid=IwAR2eE5dU82cOhsJbreGrpkdqXokbg0UpBSEFVt9q7fCloipeljnxb91UMQQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum machine learning for chemistry and physics&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-4&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Machine learning (ML) has emerged as a formidable force for identifying hidden but pertinent patterns within a given data set with the objective of subsequent generation of automated predictive behavior. In recent years, it is safe to conclude that ML and its close cousin, deep learning (DL), have ushered in unprecedented developments in all areas of physical sciences, especially chemistry. Not only classical variants of ML, even those trainable on near-term quantum hardwares have been developed with promising outcomes. Such algorithms have revolutionized materials design and performance of photovoltaics, electronic structure calculations of ground and excited states of correlated matter, computation of force-fields and potential energy surfaces informing chemical reaction dynamics, reactivity inspired rational strategies of drug designing and even classification of phases of matter with accurate identification of emergent criticality. In this review we shall explicate a subset of such topics and delineate the contributions made by both classical and quantum computing enhanced machine learning algorithms over the past few years. We shall not only present a brief overview of the well-known techniques but also highlight their learning strategies using statistical physical insight. The objective of the review is not only to foster exposition of the aforesaid techniques but also to empower and promote cross-pollination among future research in all areas of chemistry which can benefit from ML and in turn can potentially accelerate the growth of such algorithms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bài 5: Important Subroutine 3 - HHL Algorithm</title>
      <link>https://example.com/post/important-subroutine-3/</link>
      <pubDate>Fri, 09 Dec 2022 10:15:40 +0700</pubDate>
      <guid>https://example.com/post/important-subroutine-3/</guid>
      <description>&lt;meta property=&#34;og:image&#34; content=&#34;/post/important-subroutine-3/featured.png&#34;&gt;
&lt;meta property=&#34;og:image:type&#34; content=&#34;image/png&#34;&gt;
&lt;meta property=&#34;og:image:width&#34; content=&#34;200&#34;&gt;
&lt;meta property=&#34;og:image:height&#34; content=&#34;200&#34;&gt;
&lt;p&gt;Cuối cùng trong bộ 3 bài viết về các &lt;em&gt;subroutines&lt;/em&gt; của thuật toán lượng tử, mình muốn đề cập tới thuật toán &lt;em&gt;&lt;strong&gt;Harrow-Hassidim-Lloyd&lt;/strong&gt;&lt;/em&gt; (hay HHL) được đặt theo tên của ba tác giả đã giới thiệu thuật toán &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Thuật toán HHL được phát triển nhằm giải quyết phương trình hoặc hệ phương trình tuyến tính bằng máy tính lượng tử, hay nói cách khác thuật toán sẽ giải phương trình:&lt;/p&gt;

$$
Ax = b
$$

&lt;p&gt;Theo phương pháp truyền thống, phương trình trên có thể được giải bằng cách nghịch đảo ma trận $A$ và có kết quả là $x=A^{-1}b$. Tuy nhiên, việc tính toán ma trận nghịch đảo tốn rất nhiều tài nguyên khi ma trận $A$ lớn. Với một cách phố biến nhất như là &lt;em&gt;&lt;strong&gt;Gaussian emilination&lt;/strong&gt;&lt;/em&gt;, ta cần tới độ phức tạp $O(N^3)$ để nghịch đảo một ma trận $N\times N$; hay tiên tiến hơn với thuật toán &lt;em&gt;&lt;strong&gt;conjugate gradient&lt;/strong&gt;&lt;/em&gt; có độ phức tạp $O(Nsk \log{1/\epsilon})$, ở đó $s$ là tỷ lệ phấn tử có giá trị $0$ trong ma trận $A$ (&lt;em&gt;sparsity proportion&lt;/em&gt;), $k$ là tỷ số giữa giá trị riêng lớn nhất và giá trị riêng nhỏ nhất, và cuối cùng là $\epsilon$ ký hiệu cho độ sai số của thuật toán. &lt;strong&gt;Nhưng với HHL, thuật toán có thể xử lý vẫn đề ma trận nghịch đảo với $O(\log{(N)}s^2k^2/\epsilon)$&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Ở đây, mình sẽ cùng mọi người phân tích rõ hơn về thuật toán này.&lt;/p&gt;
&lt;h1 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Thuật toán HHL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;thuật-toán-hhl-a-name1a&#34;&gt;Thuật toán HHL &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Thuật toán HHL đặc biệt quan trọng cho các bài toán của QML, vì như mọi người đã biết hầu hết các thuật toán machine learning đều đi học tham số $\theta$ theo phương trình $y = \theta^{T}x$. Do đó, ta hoàn toàn có thể áp dụng HHL trong việc tìm $\theta$ trong các bài toán của machine learning.&lt;/p&gt;
&lt;p&gt;Thực chất vấn đề lớn nhất của HHL là làm sao đưa ma trận $A$ của phương trình $Ax = b$ vào máy tính lượng tử. Như mình đã đề cập rất nhiều từ các bài viết trước, các phép biến đổi trong máy tính lượng tử phải từ ma trận đơn nhất (&lt;em&gt;unitary matrix&lt;/em&gt;). Do đó, ta không thể trực tiếp dùng $A$ để biến đổi, nhưng may thay mọi ma trận đơn nhất đều có thể biểu diễn theo công thức tổng quát: $U = e^{iHt}$, trong đó $H$ là ma trận &lt;a href=&#34;https://en.wikipedia.org/wiki/Hermitian_matrix&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Hermitian&lt;/em&gt;&lt;/a&gt;, và $t$ biểu thị thời gian (mọi người có thể xem chứng minh ở &lt;strong&gt;Box 1&lt;/strong&gt;).&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Box 1:&lt;/strong&gt; Ma trận $H$ được gọi là Hermitian nếu $H = H^{\dagger}$ và $U$ là một ma trận đơn nhất khi $UU^{\dagger} = U^{\dagger}U = I$.&lt;/p&gt;
&lt;p&gt;Do đó, ta có: $UU^{\dagger} = e^{iHt}e^{-iH^{\dagger}t} = e^{iHt-iHt} = I$. Như vậy nếu $H$ là một ma trận Hermitian thì $U = e^{iHt}$ là một ma trận đơn nhất.&lt;/p&gt;
&lt;p&gt;Mọi người có thể đọc chi tiết hơn lý do hình thành của công thức trên ở Section 2.2.2 &lt;a href=&#34;https://www.academia.edu/41154803/Quantum_Computation_and_Quantum_Information_by_Nielsen_and_Chuang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nielson &amp;amp; Chuang&lt;/a&gt;.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Như vậy, ta hoàn toàn có thể sử dụng một kỹ thuật nhỏ để biến $A$ thành một ma trận Hermitian, $\tilde{A}$, để có một ma trận đơn nhất $U = e^{i\tilde{A}t}$. Ở đây, mình có thể biểu diễn $\tilde{A}$ dưới dạng:&lt;/p&gt;

$$
\tilde{A} = \left( \begin{array}{cc} 0 &amp; A^{\dagger} \\
A &amp; 0 \end{array} \right) 
$$

&lt;p&gt;Dễ dàng có thể thấy $\tilde{A} =\tilde{A}^{\dagger}$ nên $\tilde{A}$ là một ma trận Hermitian. Như vậy thay vì trực tiếp giải $x = A^{-1}b$, mình sẽ đi giải quyết bài toán $\ket{x} = \tilde{A}^{-1}\ket{b}$&lt;/p&gt;
&lt;p&gt;Mặt khác, nếu ta phân rã trị riêng của $\tilde{A}$ ta được $V\Lambda V^{-1}$ trong đó $V$ gồm các véc-tơ cột là véc-tơ riêng của $\tilde{A}$ và $\Lambda$ có các phần tử đường chéo là các giá trị riêng của $\tilde{A}$. Mà $\tilde{A} = \tilde{A}^{\dagger}$ nên dễ dàng có thể thấy $VV^{\dagger} = I$ nên $V^{-1} = V^{\dagger}$. Do đó, ta có thể viết công thức phân rã trị riêng của $\tilde{A}$ như sau:

$$
\tilde{A} = \sum_{i} \lambda_i \ket{v_i}\bra{v_i} 
$$
&lt;/p&gt;

$$
\Rightarrow \tilde{A}^{-1} = \sum_{i} \frac{1}{\lambda_i} \ket{v_i}\bra{v_i} \quad (1)
$$

&lt;p&gt;Ở đó, các véc-tơ riêng $\ket{v_i}$ tạo thành hệ cơ sở trực giao (&lt;em&gt;orthonormal basis&lt;/em&gt;), hay $\left\langle v_i| v_i \right\rangle = 1$ và $\left\langle v_i| v_j \right\rangle = 0 $. Nên ta cũng có thể biểu diễn được $\ket{b}$ theo $\ket{v_i}$:

$$
\ket{b} = \sum_{i} \beta_i \ket{v_i} \quad (2)
$$
&lt;/p&gt;
&lt;p&gt;Thay (1) và (2) vào $\ket{x} = \tilde{A}^{-1}\ket{b}$, ta được:&lt;/p&gt;
&lt;p&gt;
$$
\ket{x} = \sum_{i} \frac{1}{\lambda_i} \ket{v_i}\bra{v_i} \sum_{i} \beta_i \ket{v_i} 
$$


$$
= \sum_{i} \frac{\beta_i}{\lambda_i} \ket{v_i} \quad (3)
$$
&lt;/p&gt;
&lt;p&gt;Từ kết quả trên, có thể thấy nhiệm vụ của thuật toán HHL sẽ biến đổi đến trạng thái $\sum_{i} \frac{\beta_i}{\lambda_i} \ket{v_i}$. Sau đây, mình sẽ phân tích từng bước một trong những bước triển khai của HHL.&lt;/p&gt;
















&lt;figure  id=&#34;figure-hình-1-cấu-trúc-mạch-của-thuật-toán-hhlhttpswwwgooglecomurlsaiurlhttps3a2f2fwwwresearchgatenet2ffigure2fhhl-algorithm-process_fig1_344506252psigaovvaw3zqinvyafhbdaa7w_vto9just1670659322793000sourceimagescdvfeved0cbeqjhxqfwotcicpq42j7pscfqaaaaadaaaaabaq&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 1: Cấu trúc mạch của thuật toán HHL](https://www.google.com/url?sa=i&amp;amp;url=https%3A%2F%2Fwww.researchgate.net%2Ffigure%2FHHL-algorithm-process_fig1_344506252&amp;amp;psig=AOvVaw3ZqINVyafhbdaA7W_vtO9j&amp;amp;ust=1670659322793000&amp;amp;source=images&amp;amp;cd=vfe&amp;amp;ved=0CBEQjhxqFwoTCICpq42J7PsCFQAAAAAdAAAAABAQ)&#34; srcset=&#34;
               /post/important-subroutine-3/circuit_hu61a04533ea5e0fb5c5a8a7eeffc6ee91_36739_95716748da28af513432a8421f6a384d.webp 400w,
               /post/important-subroutine-3/circuit_hu61a04533ea5e0fb5c5a8a7eeffc6ee91_36739_77ef1a703d5596fd54e216977fd2378d.webp 760w,
               /post/important-subroutine-3/circuit_hu61a04533ea5e0fb5c5a8a7eeffc6ee91_36739_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/important-subroutine-3/circuit_hu61a04533ea5e0fb5c5a8a7eeffc6ee91_36739_95716748da28af513432a8421f6a384d.webp&#34;
               width=&#34;760&#34;
               height=&#34;329&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;https://www.google.com/url?sa=i&amp;amp;url=https%3A%2F%2Fwww.researchgate.net%2Ffigure%2FHHL-algorithm-process_fig1_344506252&amp;amp;psig=AOvVaw3ZqINVyafhbdaA7W_vtO9j&amp;amp;ust=1670659322793000&amp;amp;source=images&amp;amp;cd=vfe&amp;amp;ved=0CBEQjhxqFwoTCICpq42J7PsCFQAAAAAdAAAAABAQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hình 1: Cấu trúc mạch của thuật toán HHL&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Bước 1: Khởi tạo&lt;/strong&gt;&lt;/em&gt;
Như minh họa ở Hình 1, thuật toán HHL có đầu vào gốm có 3 thanh ghi:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Thanh ghi &lt;em&gt;&lt;strong&gt;Ancilla&lt;/strong&gt;&lt;/em&gt; gồm 1 qubit được khởi tạo bằng $\ket{0}_{ANC}$. Qubit này sẽ được sử dụng để hỗ trợ cho phép quay (&lt;em&gt;rotation&lt;/em&gt;) từ $\lambda_i\ket{v_i}$ thành $\frac{1}{\lambda_i}\ket{v_i}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thanh ghi thứ hai sẽ chịu trách nhiệm lưu giữ thông tin về giá trị riêng từ kết quả của thuật toán &lt;em&gt;&lt;strong&gt;Phase estimation - QPE&lt;/strong&gt;&lt;/em&gt;. Và tương tự với &lt;a href=&#34;https://example.com/post/important-subroutine-2/&#34;&gt;Bài 4&lt;/a&gt;, số qubits được dùng ở thanh ghi này sẽ phụ thuộc vào sai số của thuật toán QPE. Các qubits ở đây cũng được khởi tạo với giá trị $\ket{0}_{W}$.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thanh ghi cuối cùng mã hóa giá trị của $\ket{b}$. Mọi biến đổi sau này mình sẽ giả sử $\ket{b}$ đã được chuẩn hóa để đơn giản trong quá trình trình bày các công thức. Trong trường hợp khác $\ket{b}$ hoàn toàn có thể chuẩn hóa theo: $\ket{b_{norm}} = \frac{\ket{b}}{\left\langle b| b \right\rangle^{1/2}}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Như vậy, mình có thể suy ra trạng thái đầu vào của bài toán từ 3 thanh ghi trên có dạng:&lt;/p&gt;

$$
\ket{\psi_0} = \ket{0}_{ANC} \otimes \ket{0}_{W} \otimes \ket{b} 
$$

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Bước 2: Phase Estimation&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Như mình trình bày ở &lt;a href=&#34;https://example.com/post/important-subroutine-2/&#34;&gt;Bài 4&lt;/a&gt;, thuật toán QPE sẽ giúp mình tìm được giá trị riêng, $\lambda_i$, của ma trận đơn nhất $U = e^{i\tilde{A}t}$ tương ứng với véc-tơ riêng cho trước $\ket{v_i}$. Tuy nhiên, vì ta chưa biết giá trị của các véc-tơ riêng $\ket{v_i}$ của $U$, nên thay vào đó ta có thể dùng véc-tơ $\ket{b} = \sum_{i} \beta_i \ket{v_i}$ cho thuật toán QPE.&lt;/p&gt;
&lt;p&gt;Xét ma trận $\tilde{A}$ có phân rã trị riêng bằng $\sum_{j}\lambda_j \ket{v_j}\bra{v_j}$, ta có phân rã trị riêng của $e^{i\tilde{A}t}$ là:

$$
e^{i\tilde{A}t} = \sum_j e^{i\lambda_j t} \ket{v_j}\bra{v_j} 
$$
&lt;/p&gt;

$$
 = \sum_j e^{2\pi i (\frac{\lambda_j t}{2\pi})} \ket{v_j}\bra{v_j} \quad (*)
$$

&lt;p&gt;Do đó nếu mình áp dụng thuật toán QPE với ma trận đơn nhất $e^{i\tilde{A}t}$ trên véc-tơ $\ket{b}$, mình sẽ thu được trạng thái của $\tilde{\lambda} = \frac{\lambda_i t}{2\pi}$. Như vậy kết quả thu được sau khi sử dụng QPE là:

$$
\ket{\psi_0} \xrightarrow[]{QPE} \ket{\psi_1} = \ket{0}_{ANC} \otimes \sum_j \beta_j \ket{\tilde{\lambda_j}} \otimes \ket{v_j}
$$
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Bước 3: Nghịch đảo giá trị riêng (Eigenvalues Inversion)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Theo như công thức (3), mình cần tính nghịch đảo của $\lambda_i$. Ta có thể đạt được điều này bằng cách áp dụng phép quay của &lt;em&gt;ancilla qubit&lt;/em&gt; ($\ket{0}_{ANC}$) theo trục $y$ với một góc $\theta_j$ phụ thuộc vào trạng thái của $\ket{\tilde{\lambda_j}}$. Ở đây,&lt;/p&gt;
&lt;p&gt;
$$
\theta_j = 2 \sin^{-1} \frac{C}{{\lambda_j}},
$$

trong đó $C$ là một hằng số bất kỳ. Do đó phép quay $R_y(\theta_j)$ được biểu diễn dưới dạng:&lt;/p&gt;

$$
R_y(\theta_j) = \left( \begin{array}{cc} \cos(\frac{\theta_j}{2}) &amp; -\sin(\frac{\theta_j}{2}) \\
\sin(\frac{\theta_j}{2}) &amp; \cos(\frac{\theta_j}{2}) \end{array} \right) 
$$

&lt;p&gt;Phép quay này sẽ biến đổi &lt;em&gt;ancilla qubit&lt;/em&gt; ($\ket{0}_{ANC}$) thành:&lt;/p&gt;

$$
R_y(\theta_j)\ket{0}_{ANC} = \left( \begin{array}{cc} \cos(\frac{\theta_j}{2}) &amp; -\sin(\frac{\theta_j}{2}) \\
\sin(\frac{\theta_j}{2}) &amp; \cos(\frac{\theta_j}{2}) \end{array} \right)\left( \begin{array}{c} 1 \\
0  \end{array} \right) = \left( \begin{array}{c} \cos(\frac{\theta_j}{2}) \\
\sin(\frac{\theta_j}{2})  \end{array} \right) 
$$


$$
= \cos(\frac{\theta_j}{2})\ket{0} + \sin(\frac{\theta_j}{2})\ket{1} \quad (4)
$$

&lt;p&gt;Mà $\theta_j = 2 \sin^{-1} \frac{C}{\lambda_j}$, nên $\sin(\frac{\theta_j}{2}) = \frac{C}{\lambda_j}$ và $\cos(\frac{\theta_j}{2}) = \sqrt{1 - \frac{C^2}{\lambda_j^2}}$. Thay kết quả này vào công thức (4), ta được:

$$
R_y(\theta_j)\ket{0}_{ANC} = \sqrt{1 - \frac{C^2}{{\lambda_j}^2}}\ket{0} + \frac{C}{\lambda_j}\ket{1}
$$
&lt;/p&gt;
&lt;p&gt;Như vậy sau bước 3, kết quả của cả ba thanh ghi là:&lt;/p&gt;

$$
\ket{\psi_1} \longrightarrow \ket{\psi_2} = \sum_j (\sqrt{1 - \frac{C^2}{\lambda_j^2}}\ket{0}_{ANC} + \frac{C}{\lambda_j}\ket{1}_{ANC}) \otimes \beta_j \ket{\lambda_j} \otimes \ket{v_j}
$$

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Bước 4: Reverse Phase Estimation&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Vì mình đã đạt được $\frac{1}{\lambda_j}$, nên thực chất bài toán của chúng ta không còn cần tới $\ket{\lambda_j}$ ở thanh ghi thứ 2. Mình thực hiện phép nghịch đảo của thuật toán QPE. Các phép biến đổi trong máy tính lượng tử là từ các ma trận đơn nhất (&lt;em&gt;unitary matrix&lt;/em&gt;) nên luôn tồn tại ma trận nghịch đảo của chúng. Do đó ta hoàn toàn có thể thiết kế phép biến đổi nghịch đảo $QPE^{-1}$ như Hình 1 bằng cách nghịch đảo các phép toán của QPE. Từ đó, mình thu được:&lt;/p&gt;

$$
\ket{\psi_2} \rightarrow \ket{\psi_3} = \sum_j (\sqrt{1 - \frac{C^2}{\lambda_j^2}}\ket{0}_{ANC} + \frac{C}{\lambda_j}\ket{1}_{ANC}) \otimes \beta_j \ket{0}_W \otimes \ket{v_j}
$$


$$
\Rightarrow \ket{\psi_3} = \ket{0}_W \otimes \sum_j (\sqrt{1 - \frac{C^2}{\lambda_j^2}}\ket{0}_{ANC} + \frac{C}{\lambda_j}\ket{1}_{ANC}) \otimes \beta_j \ket{v_j}
$$

&lt;p&gt;Vì các qubits ở thanh ghi thứ hai được đưa vê trạng thái khởi tạo ban đầu $\ket{0}_W$ nên mình hoàn toàn có thể bỏ qua thanh ghi này ở trong bài toán của chúng ta:&lt;/p&gt;

$$
\Rightarrow \ket{\psi_3} = \sum_j  (\beta_j \sqrt{1 - \frac{C^2}{\lambda_j^2}}\ket{0}_{ANC} + \frac{C \beta_j}{\lambda_j}\ket{1}_{ANC}) \otimes \ket{v_j} \quad (5)
$$ 

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Bước 5: Measurement&lt;/strong&gt;&lt;/em&gt;
Ở bước cuối cùng này, mình thực hiện phép đo trên &lt;em&gt;ancilla qubit&lt;/em&gt; và chỉ lấy kết quả khi &lt;em&gt;ancilla qubit&lt;/em&gt; có giá trị bằng $\ket{1}$. Khi đó, từ công thức (5) ta có thể thấy kết quả của thuật toán HHL là:

$$
\ket{\psi_{final}} = C \sum_{j} \frac{\beta_j}{\lambda_j} \ket{v_j}
$$ 
&lt;/p&gt;
&lt;p&gt;Từ đây, ta có thể đấy $\ket{\psi_{final}}$ chính là kết quả $\ket{x} = \sum_{j} \frac{\beta_j}{{\lambda_j}} \ket{v_j}$ mà chúng ta cần tìm kiếm, trong đó các hằng số $C$ và $t$ có thể tinh chỉnh sao cho $C=1$. Nghe có vẻ hơi mâu thuẫn nhưng thực chất để tính toán được $\lambda_j$ ta phần nhiều dựa vào kết quả của $\ket{\tilde{\lambda_j}}$, và chính nó phụ thuộc vào giá trị của $t$. Nên thay vì ngay từ đầu chọn $C = 1$, ta cần tinh chỉnh cả 2 giá trị $C$, $t$ để thu được kết quả chính xác nhất.&lt;/p&gt;
&lt;p&gt;Có thể thấy thuật toán HHL có rất nhiều triển vọng cho sự phát triển của QML, tuy nhiên khả năng tính toán vượt trội của HHL cũng là vấn đề của nó. Câu hỏi ở đây là làm thế nào để lấy được thông tin từ véc-tơ đầu ra $\ket{x}$. Phổ thông nhất có lẽ mọi người sẽ sử dụng phép đo (&lt;em&gt;measurement&lt;/em&gt;) toàn bộ số qubits của $\ket{x}$, nhưng với bộ dữ liệu có số chiều lớn, việc thực hiện phép đo trên toàn bộ qubits sẽ tốn nhiều tài nguyên tính toán vì &lt;a href=&#34;https://en.wikipedia.org/wiki/No-cloning_theorem#:~:text=In%20physics%2C%20the%20no%2Dcloning,of%20quantum%20computing%20among%20others.&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;No-cloning Theorem&lt;/a&gt; trong máy tính lượng tử. Nên với mỗi lần thực hiện phép đo thuật toán lượng tự cần phải tạo lại các phép biến đổi từ đầu.&lt;/p&gt;
&lt;p&gt;Do đó người ta thường dùng thuật HHL theo 2 cách như sau mà vẫn giữ được khả năng tính toán vượt trội của nó:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Chiếu trạng thái của $\ket{x}$ trên một không gian nhỏ hơn và tính toán giá trị kỳ vọng (&lt;em&gt;expectation value&lt;/em&gt;) của $\ket{x}$ trên không gian đó:

$$
\mathbb{E}_O(x) = \bra{x}O\ket{x}
$$ 

Trong đó $O$ được gọi là &lt;em&gt;&lt;strong&gt;observable&lt;/strong&gt;&lt;/em&gt; có dạng của một ma trận đơn nhất. Các &lt;em&gt;observables&lt;/em&gt;, $O$, thường được dùng có thể kể đến như &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_logic_gate#Pauli_gates_%28X,Y,Z%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pauli-X, Pauli-Y, và Pauli-Z&lt;/a&gt; tương ứng với phép chiếu lên x-axis, y-axis, và z-axis của &lt;a href=&#34;https://en.wikipedia.org/wiki/Bloch_sphere&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bloch Sphere&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sử dụng HHL nhưng một chương trình con &lt;em&gt;subroutine&lt;/em&gt; cho các thuật toán khác nhằm tận dụng khả năng tính toán vượt trội của nó.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;source-code-a-name2a&#34;&gt;Source Code &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Đâu tiên ta có &lt;em&gt;&lt;strong&gt;class HamiltonianSimulation&lt;/strong&gt;&lt;/em&gt; sẽ tạo một trận đơn nhất $U$ từ ma trận Hermitian $\tilde{A}$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HamiltonianSimulation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EigenGate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SingleQubitGate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Class này sẽ tạo ma trận đơn nhất từ một ma trận Hermitian đầu vào _H_ và
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    thời gian t.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_H_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exponent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;testing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SingleQubitGate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EigenGate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exponent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exponent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_H_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_H_&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;eigen_vals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eigen_vecs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;linalg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eigh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_H_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eigen_components&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_lambda_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;zip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eigen_vals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eigen_vecs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_lambda_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;_proj_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;outer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;conj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eigen_components&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_proj_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_with_exponent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exponent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HamiltonianSimulation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_H_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exponent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_eigen_components&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eigen_components&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ở đây, như mình đã đề cập ở công thức (*), hàm trên sẽ tính ma trận đơn nhất $U$ theo $e^{i\tilde{A}t}  = \sum_j e^{2\pi i (\frac{\lambda_j t}{2\pi})} \ket{v_j}\bra{v_j}$&lt;/p&gt;
&lt;p&gt;Tiếp đến, ta có mô-đun thứ hai là &lt;em&gt;&lt;strong&gt;QuantumPhaseEstimation&lt;/strong&gt;&lt;/em&gt;. Đoạn code dưới đây hầu hết sẽ giống với code của &lt;a href=&#34;https://example.com/post/important-subroutine-2/&#34;&gt;Bài 4&lt;/a&gt;, tuy nhiên nó được cải tiến để có thể hoạt động với ma trận $U$ bất kỳ.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ControlledUnitary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Gate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_num_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_control_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_num_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_decompose_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;input_state_qubit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;control_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;enumerate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;control_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;_pow_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_control_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;#yield self.U(q, *input_state_qubit)**_pow_&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ControlledGate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_pow_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_state_qubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;QuantumPhaseEstimation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;    Class QuantumPhaseEstimation được cải tiến từ code bài 4 (https://github.com/qmlvietnam/CodeforBlog/blob/main/QPE%20(1).ipynb)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;    cho ma trận đơn nhất U bất kỳ.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s1&#34;&gt;    &amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;num_output_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initial_circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measure_or_sim&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initial_circuit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measure_or_sim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;measure_or_sim&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_output_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_output_qubits&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_output_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_output_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;raise&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;ValueError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Alteast one of num_output_qubits or output_qubits to be specified&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_output_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;inv_qft&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qft_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QFT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qft_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qft_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;print&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qft_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QFT_inv_circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qft_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inv_circuit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on_each&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ControlledUnitary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                         &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inv_qft&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QFT_inv_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;measure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simulate_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measure&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;sim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Simulator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;measure&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sim&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;simulate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sim&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;repetitions&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;histogram&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;class EigenValueInversion&lt;/strong&gt;&lt;/em&gt; triển khai phép nghịch đảo ở Bước 3. Ở đây, như mình đã đề cập giá trị $\theta_j$ bị ràng buộc bởi giá trị của $\ket{\tilde{\lambda_j}}$:

$$
\theta_j = 2 \sin^{-1} \frac{C}{{\lambda_j}},
$$
&lt;/p&gt;
&lt;p&gt;
$$
\Leftrightarrow \theta_j = 2 \sin^{-1} \frac{Ct}{{2\pi \tilde{\lambda_j}}},
$$

Từ đó, ta có thuật toán nghịch đảo giá trị riêng được triển khai như sau:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EigenValueInversion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Gate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Class EigenValueInversion sẽ nghịch đảo giá trị riêng. Ứng với mỗi giá trị riêng,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    ta áp dụng phép xoay R_y tương ứng.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EigenValueInversion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_num_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Tổng số các giá trị riêng self.N&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_num_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_decompose_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;base_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;# Với mỗi véc-tơ cở sở của |\tilde{\lambda_j}&amp;gt; ta tính phép xoay R_y(\theta_j) tương ứng &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;eig_val_gate&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_ancilla_rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;# Xác định qubits của thanh ghi thứ 2 cho phép biến đổi Controlled-R_Y &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;base_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;qubits_to_flip&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;base_state&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qubits_to_flip&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;qubits_to_flip&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;# Tạo phép biến đổi Controlled-R_Y &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;eig_val_gate&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ControlledGate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eig_val_gate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eig_val_gate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_ancilla_rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Tính \theta_j theo công thức mình đề cập ở trên&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;asin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;eig_val_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;theta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Từ 3 mô-dun trên, mình có để xây dựng thuật toán HHL một cách hoàn chỉnh&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HHL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hamiltonian&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initial_state_transforms&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        :param hamiltonian: ma trận Hermitan đầu vào 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        :param C: C
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        :param t: t
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        :param initial_state: véc-tơ |b&amp;gt; đầu vào
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hamiltonian&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hamiltonian&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state_transforms&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initial_state_transforms&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# số qubit của thanh ghi số 2 cho thuật toán QPE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;const&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;build_hhl_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Khởi tạo cấu trúc mạch cho thuật toán QFT. &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Về sau các phép biến đổi sẽ được thêm vào bằng circuit.append()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Khởi tạo Ancilla qubit = |0&amp;gt; cho thanh ghi thứ nhất&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ancilla_qubit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Khởi tạo các qubits của thanh ghi thứ 2 có giá trị |0&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# khởi tạo các qubits mã hóa véc-tơ |b&amp;gt;. Nếu initial_state_transforms = None,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# véc-tơ |b&amp;gt; được cho giá trị là |0&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hamiltonian&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                               &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;op&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state_transforms&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;op&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Tạo ma trận đơn nhất&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HamiltonianSimulation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_H_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hamiltonian&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Quantum Phase Estimation của ma trận U và véc-tơ |b&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;_qpe_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QuantumPhaseEstimation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                       &lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;_qpe_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qpe_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;CIRCUIT&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qpe_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_qpe_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Nghịch đảo giá trị riêng bằng hàm EigenValueInversion&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;_eig_val_inv_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EigenValueInversion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_eig_val_inv_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qpe_register&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ancilla_qubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Nghịch đảo các phép toán của QPE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qpe_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Thực hiện phép đo trên ancilla qubit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ancilla_qubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Thêm các observables để tính giá trị kỳ vọng&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PhasedXPowGate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;exponent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sympy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Symbol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;phase_exponent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sympy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Symbol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;phase_exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;initial_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simulate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;# # Mô phỏng chương trình trên máy tính lượng tử và in ra kết quả&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;simulator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Simulator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Khởi tạo các observables: Pauli-X, Pauli-Y, và Pauli-Z &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;phase_exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;phase_exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;phase_exponent&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;results&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;simulator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run_sweep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;repetitions&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;zip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Y&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Z&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;expectation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measurements&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;m&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;][&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;measurements&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt; = &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;format&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;expectation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Để thí nghiệm thuật toán HHL này, mình sẽ lấy ví dụ các tham số như sau:

$$
\tilde{A}\! =\! \left( \begin{array}{cc} 4.302\! -\! 6.016\!\times\! 10^{-8}j &amp; 0.235\! +\! 9.344\!\times\! 10^{-1}j\\
0.235\! -\! 9.344\!\times\! 10^{-1}j &amp; 0.584\! +\! 6.016\!\times\! 10^{-8}j \end{array} \right)
$$


$$
\ket{b} = R_z(1.276359)R_x(1.276359)\ket{0}
$$


$$
 t = 0.358166 \times \pi
$$


$$
 n = 4
$$


$$
C = \frac{ 2 \pi}{(2^nt )}
$$
&lt;/p&gt;
&lt;p&gt;Với các &lt;em&gt;observables&lt;/em&gt;: Pauli-X, Pauli-Y, và Pauli-Z, thì mình mong chờ kết quả tương ứng thu được là: $(0.144130, 0.413217, -0.899154)$.&lt;/p&gt;
&lt;p&gt;So với kết quả thu được từ thuật toán HHL trên:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.19298245614035092&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.4145995747696669&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Z&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.8652207591014718&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ta thấy thuật toán HHL mang lại kết quả khá sát so với kết quả chúng ta mong đợi. Mọi người có thể thử tăng độ chính xác bằng cách tăng giá trị $n$ trên.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Toàn bộ code của thuật toán HHL ở &lt;a href=&#34;https://github.com/qmlvietnam/CodeforBlog/blob/main/HHL.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Mọi người có thể đọc thêm bài báo gốc ở &lt;a href=&#34;https://arxiv.org/abs/0811.3171&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Bài 4: Important Subroutine 2 - Quantum Phase Estimation</title>
      <link>https://example.com/post/important-subroutine-2/</link>
      <pubDate>Thu, 08 Dec 2022 10:06:45 +0700</pubDate>
      <guid>https://example.com/post/important-subroutine-2/</guid>
      <description>&lt;meta property=&#34;og:image&#34; content=&#34;/post/important-subroutine-2/featured.jpg&#34;&gt;
&lt;meta property=&#34;og:image:type&#34; content=&#34;image/jpeg&#34;&gt;
&lt;meta property=&#34;og:image:width&#34; content=&#34;200&#34;&gt;
&lt;meta property=&#34;og:image:height&#34; content=&#34;200&#34;&gt;
Nằm thứ hai trong bộ ba bài viết về các *subroutines* quan trọng trong khoa học lượng tử nói chung và QML nói riêng, mình muốn giới thiệu mọi người về thuật toán ***Quantum Phase Estimation*** (QPE). Chính sự xuất hiện của thuật toán này đã tạo tiền đề cho nhưng ứng dụng của máy tính lượng tử cho các bài toán phức tạp dường như không thể xử lý trên máy tính truyền thống như: *period finding* hay *factoring numbers*. Do đó, mình sẽ cùng mọi người phân tích rõ hơn về thuật toán này.
&lt;h1 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Quantum Phase Estimation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Độ phức tạp của QPE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;quantum-phase-estimation-a-name1a&#34;&gt;Quantum Phase Estimation &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Cho một ma trận đơn nhất (&lt;em&gt;unitary matrix&lt;/em&gt;), $\mathcal{U}$, ta cần phải tìm giá trị riêng tương ứng với véc-tơ riêng $\ket{\psi}$ của ma trận $\mathcal{U}$. Vì $\mathcal{U}$ là một ma trận đơn nhất nên khá dễ dàng cho mình chứng minh được các giá trị riêng $\lambda$ của $\mathcal{U}$ có độ lớn là $1$ (mọi người có thể xem chứng minh ở &lt;strong&gt;Box 1&lt;/strong&gt;). Do đó, $\lambda$ hoàn toàn có thể viết dưới dạng $e^{2\pi i \phi}$, $0\leq \phi &amp;lt; 1$, vì $\lambda^{*} \lambda = e^{-2\pi i \phi + 2\pi i \phi} = e^0 = 1$. Như vậy, thuật toán &lt;em&gt;Quantum Phase Estimation&lt;/em&gt; (hay QPE) thực chất sẽ đi tính $\phi$ cho giá trị riêng $\lambda$.&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;strong&gt;Box 1:&lt;/strong&gt; Ta có $ \mathcal{U} \ket{\psi}=\lambda \ket{\psi}$ và $\mathcal{U}^{\dagger}\mathcal{U} = I$ (vì $\mathcal{U}$ là ma trận đơn nhất), nên:
$\left\langle \psi| \psi \right\rangle = \left\langle \psi| \mathcal{U}^{\dagger} \mathcal{U} |\psi \right\rangle = \bra{\psi} \lambda^{*} \lambda \ket{\psi} = |\lambda|^2\left\langle \psi| \psi \right\rangle $. Do đó, $|\lambda|^2 = 1$
  &lt;/div&gt;
&lt;/div&gt;
















&lt;figure  id=&#34;figure-hình-1-cấu-trúc-mạch-của-thuật-toán-qpehttpsenwikipediaorgwikiquantum_phase_estimation_algorithm&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 1: Cấu trúc mạch của thuật toán QPE](https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm)&#34; srcset=&#34;
               /post/important-subroutine-2/circuit_huc47373d4e794d44fd5d3937ab331d6cf_50019_e3d96adbcc7732115428a8fd72b34728.webp 400w,
               /post/important-subroutine-2/circuit_huc47373d4e794d44fd5d3937ab331d6cf_50019_b72b67cafa57ac3352e62736c7bfc2c7.webp 760w,
               /post/important-subroutine-2/circuit_huc47373d4e794d44fd5d3937ab331d6cf_50019_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/important-subroutine-2/circuit_huc47373d4e794d44fd5d3937ab331d6cf_50019_e3d96adbcc7732115428a8fd72b34728.webp&#34;
               width=&#34;760&#34;
               height=&#34;313&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hình 1: Cấu trúc mạch của thuật toán QPE&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Cấu trúc mạch của thuật toán QPE được minh họa ở Hình 1. Thuật toán sẽ có 2 thành phần chính: với thanh ghi đầu tiên, gồm $n$ qubits được khởi tạo ban đầu bằng $\ket{0}$, chịu trách nhiệm giữ nhưng thông tin về $\phi$ sau khi thuật toán kết thúc; còn thanh ghi thứ 2 mã hóa giá trị của véc-tơ riêng $\ket{\psi}$. Vì giá trị của $\phi$ bất định trong khoảng $[0,1)$ nên có thể thấy rằng giá trị của $n$ dùng để giải mã $\phi$ sẽ linh hoạt tùy thuộc độ chính xác mà chúng ta mong muốn (mọi người có thể xem giải thích ở &lt;strong&gt;Box 2&lt;/strong&gt;).&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    &lt;p&gt;&lt;strong&gt;Box 2:&lt;/strong&gt; Ta có $\phi \in [0,1)$, tương tự với thuật toán QFT ở &lt;a href=&#34;https://example.com/post/important-subroutine-1/&#34;&gt;Bài 3&lt;/a&gt;, mình có thể biểu diễn dưới dạng nhị phân như sau:&lt;/p&gt;
&lt;p&gt;$$
\phi = 0.\phi_1\phi_2&amp;hellip;\phi_k\phi_{k+1}&amp;hellip;
$$&lt;/p&gt;
&lt;p&gt;Vì $\phi$ chưa xác định nên giả sử ta dùng $n$ qubit để giải mã $\phi$ thì luôn tồn tại giá trị $\epsilon \geq 0$ sao cho&lt;/p&gt;
&lt;p&gt;$$
\phi = 0.\phi_1\phi_2&amp;hellip;\phi_n + \epsilon
$$&lt;/p&gt;
&lt;p&gt;Trong đó $\epsilon = 0$ khi và chỉ khi $\phi$ có thể biểu diễn chính xác với $n$ qubits. Do đó độ chính xác của thuật toán QPE sẽ phù thuộc vào mọi người tinh chỉnh giá trị $n$.&lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Như mọi người có thể thấy ở Hình 1, thuật toán QPE gồm có 3 bước:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Bước 1:&lt;/strong&gt;&lt;/em&gt; Sử dụng cổng Hadamard lên các qubits  ở thanh ghi đầu tiên. Vì các qubits được khởi tạo bằng véc-tơ $\ket{0}$ nên:

$$
\ket{q^1} = H^{\otimes n} \ket{0}^{\otimes n} = \frac{1}{2^{n/2}} (\ket{0}+\ket{1})(\ket{0}+\ket{1})...(\ket{0}+\ket{1})  
$$


$$
 = \frac{1}{2^{n/2}} \sum_{k=0}^{2^n-1}\ket{k}
$$

&lt;em&gt;&lt;strong&gt;Bước 2:&lt;/strong&gt;&lt;/em&gt; Lần lượt biến đổi qubits ở thanh ghi thứ hai với ma trận $\mathcal{U}^{2^{n-m}}$; ở đó, phép biến đổi này sẽ phụ thuộc vào qubit thứ $m$ của thanh ghi đầu tiên, $\ket{q^1_m}$. Nếu $\ket{q^1_m} = \ket{0}$, phép biến đổi sẽ giữ nguyên giá trị của $\ket{\psi}$ ở thanh ghi thứ hai, và nó chỉ thực hiện biến đổi với ma trận $\mathcal{U}^{n-m}$ khi $\ket{q^1_m} = \ket{1}$. Do đó, mình có thể ký hiệu phép đổi này là &lt;em&gt;controlled- $\mathcal{U}^{2^{n-m}}$&lt;/em&gt; (hay $C-U^{2^{n-m}}$ như Hình 1). Như vậy, cổng $C-U^{2^{n-m}}$ sẽ biến đổi bài toán của chúng ta như sau:

$$
(C-U^{2^{n-m}}) \ket{\psi} \frac{1}{\sqrt{2}} (\ket{0}+\ket{1}) =  \frac{1}{\sqrt{2}} (\ket{\psi}\ket{0}+\mathcal{U}^{2^{n-m}}\ket{\psi}\ket{1})
$$


$$
 = \frac{1}{\sqrt{2}} (\ket{\psi}\ket{0}+\lambda^{2^{n-m}}\ket{\psi}\ket{1}) = \frac{1}{\sqrt{2}} (\ket{\psi}\ket{0}+e^{2\pi i \phi 2^{n-m}}\ket{\psi}\ket{1})
$$


$$
 = \ket{\psi} \otimes \frac{1}{\sqrt{2}} (\ket{0}+e^{2\pi i \phi 2^{n-m}}\ket{1})
$$

Có thể thấy, phép biến đổi &lt;em&gt;controlled- $\mathcal{U}^{2^{n-m}}$&lt;/em&gt; thực chất không thay đổi trạng thái của thanh ghi thứ hai, $\ket{\psi}$, mà nó sẽ thay đổi trạng thái của qubit $\ket{q^1_m}$. Từ đây bài toán đưa ta về vấn đề giống với thuật toán QFT ở &lt;a href=&#34;https://example.com/post/important-subroutine-1/&#34;&gt;Bài 3&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Giả sử, $\phi$ được biểu diễn dưới dạng nhị phân:

$$
\phi = 0.\phi_1\phi_2...\phi_n=\phi_1 2^{-1}+\phi_2 2^{-2}+...+\phi_n 2^{-n}
$$

Với m = 1, ta có:

$$
\phi 2^{n-1} =\phi_1 2^{n-2}+\phi_2 2^{n-3}+...+\phi_n 2^{-1}
$$


$$
\Rightarrow e^{2\pi i \phi 2^{n-1}} =e^{2\pi i \phi_1 2^{n-2}}e^{2\pi i \phi_2 2^{n-3}}...e^{2\pi i\phi_n 2^{-1}}
$$

Mặt khác, mình có thể thấy $e^{2\pi i} = 1$ nên $e^{2\pi ik} = 1 \forall k \in \mathbb{Z}$. Từ đó có thể dễ dàng suy ra tất cả các phần tử trong công thức trên đều bằng 1 trừ $e^{2\pi i \phi_n 2^{-1}}$, nên

$$
e^{2\pi i \phi 2^{n-1}} = 1.1.1...e^{2\pi i \phi_n 2^{-1}} = e^{2\pi i 0.\phi_n}
$$

Tương tự ta cũng có thể suy ra:

$$
e^{2\pi i \phi 2^{n-2}} = e^{2\pi i 0.\phi_{n-1}\phi_n}
$$


$$
...
$$


$$
e^{2\pi i \phi 2^{0}} = e^{2\pi i 0.\phi_1\phi_2...\phi_{n-1}\phi_n} 
$$

Như vậy nếu mình tổng hợp những kết quả này ta có trạng thái ở các qubits của $\ket{q^1}$ là:

$$
\ket{q^1}\!=\!\frac{1}{2^{\frac{n}{2}}}\!(\!\ket{0}\!+\!e^{2\pi i 0.\phi_n}\ket{1}\!)\!(\!\ket{0}\!+\!e^{2\pi i 0.\phi_{n-1}\phi_n}\ket{1}\!)\!...\!(\!\ket{0}\!+\!e^{2\pi i 0.\phi_1\phi_2...\phi_n} \ket{1}\!)\!
$$

Như mình đã chứng minh ở &lt;a href=&#34;https://example.com/post/important-subroutine-1/&#34;&gt;Bài 3&lt;/a&gt;, kết quả trên bằng với $\frac{1}{2^{n/2}} \sum_{k=0}^{2^n-1} e^{\frac{2\pi ik\phi}{2^n}} \ket{k}$, và nó chính là kết quả của phép biến đổi Fourier từ $\phi$.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Bước 3:&lt;/strong&gt;&lt;/em&gt; Áp dụng thuật toán nghịch đảo của QFT để biến đổi:&lt;br&gt;

$$
\frac{1}{2^{n/2}} \sum_{k=0}^{2^n-1} e^{\frac{2\pi ik\phi}{2^n}} \ket{k} \longrightarrow \ket{\phi}
$$

Thực chất các phép biến đổi trong máy tính lượng tử là từ các ma trận đơn nhất (&lt;em&gt;unitary matrix&lt;/em&gt;) nên luôn tồn tại ma trận nghịch đảo của chúng. Do đó ta hoàn toàn có thể thiết kế phép biến đổi nghịch đảo $QFT^{-1}$ như Hình 1 bằng cách nghịch đảo các phép toán của QFT.&lt;/p&gt;
&lt;h1 id=&#34;độ-phức-tạp-của-qpea-name2a&#34;&gt;Độ phức tạp của QPE&lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Như Hình 1, ta có thể thấy thuật toán gồm có $n$ cổng Hadamard, $n$ cổng từ phép biến đổi &lt;em&gt;controlled- $\mathcal{U}^{2^{n-m}}$&lt;/em&gt;, và cuối cùng là $O(n^2)$ phép toán từ $QFT^{-1}$. Do đó, thuật toán QPE có độ phức tạp là $O(n^2)$.&lt;/p&gt;
&lt;p&gt;Tuy nhiên đó là trong trường hợp lý tưởng khi $\phi$ có thể được biểu diễn với chính xác $n$ qubits. Với sai số $\epsilon$ rất nhỏ, người ta đã chỉ ra rằng thuật toán QPE cần $n \propto O(\log{1/\epsilon})$ qubit và $O(1/\epsilon)$ phép biến &lt;em&gt;controlled- $\mathcal{U}$&lt;/em&gt;. Chi tiết về kết luận này mọi người có thể tìm hiểu rõ hơn ở Section 5.2.1 &lt;a href=&#34;https://www.academia.edu/41154803/Quantum_Computation_and_Quantum_Information_by_Nielsen_and_Chuang&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nielson &amp;amp; Chuang&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;source-codea-name3a&#34;&gt;Source Code&lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;QPE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_input_state_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;unitary_transform&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;input_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Số qubits của thanh ghi đầu tiên như mình đề cập ở trên&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# khởi tạo qubits có giá trị bằng |0&amp;gt; ở thanh ghi thứ nhất&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Khởi tạo cấu trúc mạch cho thuật toán. &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Về sau các phép biến đổi sẽ được thêm vào bằng circuit.append()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# véc-tơ riêng |\psi&amp;gt; đầu vào&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;input_state&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_state&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_input_state_qubits&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# khởi tạo qubits để mã hóa véc-tơ |\psi&amp;gt; đầu vào&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                             &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                   &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num_input_state_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Mã hóa |\psi&amp;gt; theo các giá trị của input_state&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_state&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;enumerate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Ma trận đơn nhất U đầu vào.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Ở đây mọi người có thể tùy ý chọn một ma trận đơn nhất bất kỳ cho tham số U,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# ngoài ra ở đây mình đưa ra một vài ví dụ cho U: cổng Identity, X, và Z.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unitary_transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unitary_transform&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unitary_transform&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;I&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unitary_transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;custom&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unitary_transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Z&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CZ&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;elif&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unitary_transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;X&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CX&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;raise&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;NotImplementedError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;self.unitary transform not Implemented&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;phase_1_create_circuit_iter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Triển khai Bước 1 và Bước 2 như mình đã đề cập ở trên&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Bước 1: Các ancilla qubits bị theo đổi theo cổng Hadamard (cirq.H)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Bước 2: Áp dụng phép biến đổi C-U^{2^m} trên input_qubits và bị ràng buộc bới các output_qubits     &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;_pow_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_ancillia_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;c1&#34;&gt;#_pow_ = 2 ** (i)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_pow_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;inv_qft&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;# Phép nghịch đảo của thuật toán QFT.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;# Mình sẽ lấy code của bài trước, mọi người có thể xem qua ở https://github.com/qmlvietnam/CodeforBlog/blob/main/QFT.ipynb&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;# để đọc rõ hơn các tính nghịch đảo của QFT. &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qft_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QFT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;output_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_qft_&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qft_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simulate_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;# Chạy mô phỏng máy tính lượng tử cho thuật toán&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;sim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Simulator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sim&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;simulate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Giờ mình sẽ chạy chương trình với cổng $Z$ có dạng  
$\left( \begin{array}{cc} 1 &amp; 0 \\ 

0 &amp; -1 \end{array} \right)$
. Có thể ma trận trên có 2 giá trị riêng là $1$ và $-1$ tương ứng với 2 véc-tơ riêng $\ket{0}$ và $\ket{1}$. Nếu mình chạy chương trình trên với véc-tơ riêng $\ket{\psi} = \ket{1}$, chúng ta mong chờ kết quả $e^{2\pi i \phi} = -1 \Leftrightarrow \phi=0.5$.&lt;/p&gt;
&lt;p&gt;Với trường hợp trên, mình sẽ dùng 2 qubits cho thanh ghi đầu tiền và 1 qubit để mã hóa véc-tơ riêng $\psi$. Kết quả của chương trình như sau:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;output&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;101&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;⟩&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Trong đó ta thấy qubit cuối cùng tương ứng với giá trị của véc-tơ riêng $\psi$ đầu vào. Do đó ta có trạng thái của 2 qubit ở thanh ghi đầu tiên $\ket{q_1q_2}$ là $\ket{10}$ tương ứng cho giá trị của $\phi = 0.q_1q_2 = 1\times2^{-1} + 0\times 2^{-2} = 0.5$. Kết quả này hoàn toàn đúng như những gì ta tìm kiếm.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Mọi người có thể xem toàn bộ code của chương trình trên ở &lt;a href=&#34;https://github.com/qmlvietnam/CodeforBlog/blob/main/QPE%20%281%29.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Bài 3: Important Subroutine 1 - Quantum Fourier Transform</title>
      <link>https://example.com/post/important-subroutine-1/</link>
      <pubDate>Sun, 27 Nov 2022 14:06:05 +0700</pubDate>
      <guid>https://example.com/post/important-subroutine-1/</guid>
      <description>&lt;meta property=&#34;og:image&#34; content=&#34;/post/important-subroutine-1/featured.png&#34;&gt;
&lt;meta property=&#34;og:image:type&#34; content=&#34;image/png&#34;&gt;
&lt;meta property=&#34;og:image:width&#34; content=&#34;200&#34;&gt;
&lt;meta property=&#34;og:image:height&#34; content=&#34;200&#34;&gt;
&lt;p&gt;Ở phần này mình sẽ có 3 bài viết nói về 3 &lt;em&gt;subroutines&lt;/em&gt; rất quan trọng tạo nên khả năng tính toán vượt trội của thuật toán lượng tử: Quantum Fourier Transform, Quantum Phase Estimation, and HHL algorithm. Những thuật toán trên có mặt nhiều trong các bài toán của QML. Do đó mình tin rằng việc nắm rõ những thuật toán này đầu tiên sẽ giúp các bạn trong việc tìm hiều các thuật toán của QML.&lt;/p&gt;
&lt;p&gt;Để khởi đầu trong danh sách trên mình sẽ trình bày thuật toán &lt;em&gt;&lt;strong&gt;Quantum Fourier Transform (QFT)&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;h1 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Discrete Fourier Transform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Quantum Fourier Transform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Độ phức tạp của QFT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;discrete-fourier-transform-a-name1a&#34;&gt;Discrete Fourier Transform &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Fourier Transform&lt;/em&gt; đã và đang xuất hiện trong rất nhiều ứng dụng ở máy tính truyền thống, có thể kể đến như: &lt;em&gt;signal processing&lt;/em&gt; hay &lt;em&gt;data compression&lt;/em&gt;. Fourier Transform sẽ biến đổi một hàm số hoặc một véc-tơ theo miền thời gian hoặc không gian sang miền tần số. Ví dụ Discrete Fourier Transform (DFT) của một biến rời rạc $\mathcal{X_N} = \{x_0, x_1, &amp;hellip;, x_{N-1}\} \in \mathbb{C}^N$ có dạng:&lt;/p&gt;
&lt;p&gt;
$$
y_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x_j e^{\frac{2\pi ijk}{N}},
$$

Từ đó phép biến đổi sẽ cho ra một chuỗi mới $\mathcal{Y_N} = \{y_0, y_1, &amp;hellip;, y_{N-1}\} \in \mathbb{C}^N$ cùng chiều với chuỗi đầu vào.&lt;/p&gt;
&lt;p&gt;Mặt khác, mình muốn đề cập tới hàm &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Kronecker_delta&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kronecker delta&lt;/a&gt;&lt;/em&gt;, $\delta_{Nj}$, được định nghĩa là một véc-tơ $N$ chiều, có giá trị 1 ở vị trí thứ $j$ và 0 ở các vị trí còn lại. Do đó, mình hoàn toàn có thể coi hàm Kronecker delta là các véc-tơ cơ sở trực chuẩn cho biến $\mathcal{X_N}$:&lt;/p&gt;

$$
\mathcal{X_N} = \sum_{j=0}^{N} x_j \delta_{Nj}
$$

&lt;p&gt;Không mất tính tổng quát, mình vẫn hoàn toàn có thể lấy hàm Kronecker delta như các véc-tơ cơ sở trực chuẩn $\ket{j}$ sẽ được sử dụng cho thuật toán lượng tử của chúng ta. Nói cách khác, biến $\mathcal{X_N}$ sẽ được mã hóa trong thuật toán lượng tử có dạng &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;:

$$
\ket{\mathcal{X_N}} = \sum_{j=0}^{N} x_j \ket{j} 
$$
&lt;/p&gt;
&lt;p&gt;Khác phép biến đổi Fourier trên máy tính truyền thống, thuật toán &lt;em&gt;Quantum Fourier Transform&lt;/em&gt; sẽ biến đổi các véc-tơ cơ sở trực chuẩn $\ket{j}$:&lt;/p&gt;

$$
\ket{j} \longrightarrow \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{\frac{2\pi ijk}{N}} \ket{k}
$$

&lt;p&gt;Và nó tương đương với việc:&lt;/p&gt;
&lt;p&gt;
$$
\sum_{j=0}^{N-1}x_j \ket{j} \longrightarrow \sum_{k=0}^{N-1} y_k \ket{k}
$$


$$
\ket{\mathcal{X_N}} \longrightarrow \ket{\mathcal{Y_N}}
$$

Vậy chi tiết đằng sau phép biến đổi này như thế nào, mình sẽ đi tới phần tiếp theo.&lt;/p&gt;
&lt;h1 id=&#34;quantum-fourier-transform-a-name2a&#34;&gt;Quantum Fourier Transform &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Với biến $\mathcal{X_N}$ gồm $N$ phần tử, mình cần $n = \log_2{N}$ qubits để biểu diễn toàn bộ các véc-tơ $\ket{j}$. Ở đây, $j$ được biểu diễn dưới dạng nhị phân $j_1j_2&amp;hellip;j_n$ sao cho:&lt;br&gt;

$$
j = j_1 2^{n-1} + j_2 2^{n-2} + ...+ j_n 2^0
$$

Và để thuận tiện hơn trong việc phát triển công thức dưới đây, mình sẽ ký hiệu $0.j_lj_{l+1}&amp;hellip;j_m = j_l/2 + j_{l+1}/4+&amp;hellip;+j_m/2^{m-l+1}$.&lt;/p&gt;
















&lt;figure  id=&#34;figure-hình-1-cấu-trúc-mạch-của-thuật-toán-qfthttpmmrcamsscascntlb201702w020170224608149940643pdf&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Hình 1: Cấu trúc mạch của thuật toán QFT](http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf)&#34; srcset=&#34;
               /post/important-subroutine-1/qft_hu25819577ab233bed1712f4a34c37adca_22534_7e2671beee401b179fb980356bec81c0.webp 400w,
               /post/important-subroutine-1/qft_hu25819577ab233bed1712f4a34c37adca_22534_a9691a20ff04305b8483f4a51ee38477.webp 760w,
               /post/important-subroutine-1/qft_hu25819577ab233bed1712f4a34c37adca_22534_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://example.com/post/important-subroutine-1/qft_hu25819577ab233bed1712f4a34c37adca_22534_7e2671beee401b179fb980356bec81c0.webp&#34;
               width=&#34;760&#34;
               height=&#34;199&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;http://mmrc.amss.cas.cn/tlb/201702/W020170224608149940643.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hình 1: Cấu trúc mạch của thuật toán QFT&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Hãy bắt đầu với qubit đầu tiên $\ket{j_1}$, cổng Hadamard (&lt;em&gt;H gate&lt;/em&gt;) biến đổi trạng thái của $\ket{j_1}$ thành $\frac{1}{\sqrt{2}}(\ket{0}+(-1)^{j_1}\ket{1})$. Mình thay $(-1) = e^{\pi i}$, ta được:

$$
H\ket{j_1} = \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i (\frac{j_1}{2})}\ket{1}) = \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i 0.j_1} \ket{1}) 
$$
&lt;/p&gt;
&lt;p&gt;Qubit này tiếp đến được biến đổi theo ${\mathbf{R}}_m$ bị ràng buộc bởi giá trị của $j_m$:

$$
{\mathbf{R}}_m = \left( \begin{array}{cc} 1 &amp; 0 \\
0 &amp; e^{\frac{2\pi i j_m}{2^m}} \end{array} \right) 
$$

Như vậy nếu thực hiện phép biến đổi ${\mathbf{R}}_2$ trên qubit thứ nhất ta được:

$$
 \left( \begin{array}{cc} 1 &amp; 0 \\
0 &amp; e^{\frac{2\pi i j_2}{2^2}} \end{array} \right) \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i 0.j_1} \ket{1}) = \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i (0.j_1+j_2/2^2)} \ket{1})
$$


$$
 = \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i 0.j_1j_2} \ket{1})
$$
&lt;/p&gt;
&lt;p&gt;Tương tự như vậy ta tiếp tục áp dụng phép biến đổi ${\mathbf{R}}_3$, ${\mathbf{R}}_4$,&amp;hellip; ${\mathbf{R}}_n$ mình có trạng thái của qubit thứ nhất được biểu diễn như sau:

$$
\ket{j_1} \longrightarrow \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i 0.j_1j_2...j_n} \ket{1})
$$
&lt;/p&gt;
&lt;p&gt;Lần lượt như vậy mình dùng các phép biến đổi tương tự cho các qubit tiếp theo, thu được:

$$
\ket{j_2} \longrightarrow \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i 0.j_2...j_n} \ket{1})
$$


$$
\ket{j_3} \longrightarrow \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i 0.j_3...j_n} \ket{1})
$$


$$
...
$$


$$
\ket{j_n} \longrightarrow \frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi i 0.j_n} \ket{1})
$$
&lt;/p&gt;
&lt;p&gt;Như vậy nếu mình tổng hợp các kết quả từ $n$ qubits, bài toán của mình sẽ được biểu diễn như sau:


$$
\ket{j_1j_2...j_n} \! \longrightarrow \!
$$
&lt;/p&gt;


$$
 \frac{1}{2^\frac{n}{2}}(\ket{0}+e^{2\pi i 0.j_1j_2...j_n} \ket{1})(\ket{0}+e^{2\pi i 0.j_2...j_n} \ket{1})...(\ket{0}+e^{2\pi i 0.j_n} \ket{1})
$$

&lt;p&gt;Và bước cuối cùng mình sẽ &lt;em&gt;swap&lt;/em&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; trạng thái của qubit thứ $m$ với qubit thứ $n-m$, hay nói cách khác mình đảo ngược thứ tự trạng thái của các qubit:


$$
 \frac{1}{2^\frac{n}{2}}(\ket{0}\!+\!e^{2\pi i 0.j_n} \ket{1})(\ket{0}\!+\!e^{2\pi i 0.j_{n-1}j_n} \ket{1})...(\ket{0}\!+\!e^{2\pi i 0.j_1j_2...j_n} \ket{1}) \quad (*)
$$ 
&lt;/p&gt;
&lt;p&gt;Đến đây, mọi người có thể vẫn còn thắc mắc về kết quả trên nên mình sẽ đi sâu hơn để giải thích kết quả này. Như mình trình bày ở trên thuật toán QFT sẽ biến đổi các véc-tơ cơ sở $\ket{j}$ thành $\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{\frac{2\pi ijk}{N}} \ket{k}$. Nếu mình thay $N = 2^n$ và $\ket{j} = \ket{j_1j_2&amp;hellip;j_n}$, ta được:

$$
\ket{j_1j_2...j_n} \longrightarrow \frac{1}{2^{n/2}} \sum_{k=0}^{2^n-1} e^{\frac{2\pi ijk}{2^n}} \ket{k}
$$

Mặt khác mình cũng có thể biểu diễn $k$ theo dạng nhị phân:

$$
k = k_1 2^{n-1}+k_2 2^{n-2}+...+k_n2^0
$$

nên&lt;/p&gt;

$$
\frac{k}{2^n} = k_1 2^{-1}+k_2 2^{-2}+...+k_n2^{-n} = \sum_{p=1}^{n}\frac{k_p}{2^p}
$$

&lt;p&gt;Thay kết quả này vào công thức trên ta có:

$$
\ket{j_1j_2...j_n} \longrightarrow \frac{1}{2^{n/2}} \sum_{k_1=0}^{1}...\sum_{k_n=0}^{1} e^{2\pi ij (\sum_{p=1}^{n}\frac{k_p}{2^p})} \ket{k_1k_2...k_n}
$$


$$
\ket{j_1j_2...j_n} \longrightarrow \frac{1}{2^{n/2}} \sum_{k_1=0}^{1}...\sum_{k_n=0}^{1}\prod_{p=1}^{n} e^{2\pi ij (\frac{k_p}{2^p})} \otimes_{p=1}^{n}\ket{k_p}
$$
&lt;/p&gt;
&lt;p&gt;$\otimes$ ký hiệu cho &lt;a href=&#34;https://en.wikipedia.org/wiki/Tensor_product&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;tensor product&lt;/em&gt;&lt;/a&gt;. Trong các bài toán lượng tử trạng thái của một hệ qubits $\ket{k_1k_2&amp;hellip;k_n}$ là &lt;em&gt;tensor product&lt;/em&gt; của các trạng thái của từng qubit $\otimes_{p=1}^{n}\ket{k_p}$.&lt;/p&gt;
&lt;p&gt;Quay lại bài toán, kết quả chúng ta có thể đơn giải hóa bằng cách đưa các tổng $\sum_{k_i}$ vào trong tensor product:

$$
\ket{j_1j_2...j_n} \longrightarrow \frac{1}{2^{n/2}} \otimes_{p=1}^{n} (\sum_{k_p=0}^{1} e^{2\pi ij (\frac{k_p}{2^p})} \ket{k_p})
$$


$$
\ket{j_1j_2...j_n} \longrightarrow \frac{1}{2^{n/2}} \otimes_{p=1}^{n} (\ket{0} + e^{2\pi ij 2^{-p}} \ket{1})
$$


$$
= \frac{1}{2^{n/2}} (\ket{0} + e^{2\pi ij 2^{-1}} \ket{1})(\ket{0} + e^{2\pi ij 2^{-2}} \ket{1})...(\ket{0} + e^{2\pi ij 2^{-n}} \ket{1}) \quad (1)
$$

Mà mình lại có $j = j_1 2^{n-1} + j_2 2^{n-2} + &amp;hellip;+ j_n 2^0$ nên $j2^{-p}$ sẽ có dạng

$$
j2^{-p} = j_1 2^{n-1-p} + j_2 2^{n-2-p} + ...+ j_n 2^{-p}
$$

Ta xét trường hợp đầu tiên với p = 1:

$$
e^{2\pi ij 2^{-1}} = e^{2\pi i(j_1 2^{n-2} + j_2 2^{n-3} + ...+ j_n 2^{-1})}
$$

Mặt khác, mình có thể thấy $e^{2\pi i} = 1$ nên $e^{2\pi im} = 1 \forall m \in \mathbb{Z}$. Từ đó có thể dễ dàng suy ra tất cả các phần tử trong công thức trên đều bằng 1 trừ $e^{2\pi i j_n 2^{-1}}$, nên

$$
e^{2\pi ij 2^{-1}} = 1.1.1...e^{2\pi i j_n 2^{-1}} = e^{2\pi i 0.j_n}
$$

Tương tự ta cũng có thể suy ra:

$$
e^{2\pi ij 2^{-2}} = e^{2\pi i 0.j_{n-1}j_n} 
$$
&lt;/p&gt;

$$
e^{2\pi ij 2^{-3}} = e^{2\pi i 0.j_{n-2}j_{n-1}j_n} 
$$

&lt;p&gt;
$$
...
$$


$$
e^{2\pi ij 2^{-n}} = e^{2\pi i 0.j_1j_2...j_{n}} 
$$

Thay những kết quả này vào công thức &lt;strong&gt;(1)&lt;/strong&gt;, mình thu được:

$$
\ket{j}\! \rightarrow\! \frac{1}{2^{n/2}} (\ket{0}\! +\! e^{2\pi i0.j_n} \ket{1})(\ket{0}\! +\! e^{2\pi i0.j_{n-1}j_n} \ket{1})...(\ket{0}\! +\! e^{2\pi i0.j_1j_2...j_n} \ket{1})
$$
&lt;/p&gt;
&lt;p&gt;Và chính kết quả này &lt;strong&gt;giống với&lt;/strong&gt; kết quả thu được từ thuật toán QFT ở &lt;strong&gt;(*)&lt;/strong&gt;. Nói cách khác, với thuật toán QFT, máy tính lượng tử vẫn có khả năng tính toán phép biến đổi Fourier với kết quả tương đương. Tuy nhiên điều thú vị của thuật toán QFT nằm ở khả năng tính toán vượt trội của nó, và sau đây mình sẽ cùng mọi người phân tích rõ hơn về độ phức tạp của QFT.&lt;/p&gt;
&lt;h1 id=&#34;độ-phức-tạp-của-qft-a-name3a&#34;&gt;Độ phức tạp của QFT &lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Ở đây, mình sẽ coi độ phức tạp tương đương với số phép biến đổi của thuật toán. Đầu tiên với qubit thứ nhất, mình có một cổng Hadamard và $n-1$ cổng $\mathcal{R_m}$, $m = {2,3,&amp;hellip;,n}$. Do đó sẽ có tổng $n$ phép biến đổi được thực hiện trên qubit đầu tiên ở bước này. Tương tự như vậy qubit thứ 2 sẽ có $1 + (n-2)=(n-1)$ phép biến đổi, &amp;hellip; Tất cả ta có

$$
\Theta([n+(n-1)+...+1]+kn) = \Theta(\frac{n(n+1)}{2}+kn) = \Theta(n^2)
$$

Trong đó $kn$ là số phép biến đổi cho thao tác đạo ngược (&lt;em&gt;swap&lt;/em&gt;) trạng thái của qubits như mình đề cập ở trên. Vì số phép biến đổi của thao tác này luôn tuyến tính với số qubits $n$ sẽ không ảnh hưởng nhiều trong việc phân tích độ phức tạp của QFT, nên mình sẽ có đi sâu về nó. Để rõ ràng hơn mọi người có thể xem cấu tạo của phép &lt;em&gt;swap&lt;/em&gt; trên ở &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_logic_gate#Swap_gate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Như vậy với thuật toán Quantum Fourier Transform (QFT) có thể thực hiện phép biến đổi Fourier với độ phức tạp $\Theta(n^2)$. Với một so sánh tương đương với thuật toán &lt;a href=&#34;https://en.wikipedia.org/wiki/Fast_Fourier_transform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fast Fourier Transform&lt;/a&gt; (FFT) cùng cho bài toán của biến rời rạc (&lt;em&gt;discrete fourier transform&lt;/em&gt;) có $2^n$ phần tử thì thuật toán FFT sẽ cần tới $\Theta(n2^n)$ phép biến đổi. Có thể thấy QFT mang lại hiệu năng vượt trội so với FFT. Trong khi FFT đang được sử dụng và đóng vai trò rất quan trọng trong nhiều ứng dụng thực tế: nhận diện giọng nói, hình ảnh, &amp;hellip;, việc xuất hiện của QFT trong các ứng dụng đó sẽ không dễ dàng, do chúng ta sẽ khó có thể trực tiếp lấy được &lt;em&gt;amplitudes&lt;/em&gt; từ kết quả của QFT thông qua phép đo (&lt;em&gt;measurement&lt;/em&gt;). Do đó, thay vì trực tiếp chuyển các &lt;em&gt;amplitudes&lt;/em&gt; của QFT sang giá trị &lt;em&gt;&amp;ldquo;classical&amp;rdquo;&lt;/em&gt;, QFT lại thường được sử dụng trong các thuật toán lượng tử khác đặc biệt là các thuật toán QML vì hiệu năng vượt trội của nó.&lt;/p&gt;
&lt;h1 id=&#34;source-code-a-name4a&#34;&gt;Source Code &lt;a name=&#34;4&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Trên đây, mình đã phân tích những biến đổi và các bước triển khai của thuật toán QFT. Ở phần này, mình sẽ thực hành cùng mọi người bằng cách triển khai thuật toán này bằng &lt;a href=&#34;https://quantumai.google/cirq&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cirq&lt;/a&gt; một &lt;em&gt;framework&lt;/em&gt; được cung cấp bởi &lt;a href=&#34;https://quantumai.google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Quantum AI&lt;/a&gt; giúp người dùng có thể mô phỏng chương trình của máy tính lượng tử sử dụng ngôn ngữ lập trình Python.&lt;/p&gt;
&lt;p&gt;Trước khi đi vào chi tiết, mình muốn nhắc lại thuật toán &lt;em&gt;Quantum Fourier Transform&lt;/em&gt; sẽ biến đổi các véc-tơ cơ sở trực chuẩn $\ket{j}$:&lt;/p&gt;

$$
\ket{j} \longrightarrow \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{\frac{2\pi ijk}{N}} \ket{k} \quad (**)
$$

&lt;p&gt;Do đó với mỗi véc-tơ đầu vào $\ket{j}$, thì thuật toán QFT sẽ cho ra một véc-tơ trực chuẩn mới tương ứng&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;cirq&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;numpy&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;np&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;QFT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    Quantum Fourier Transform
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signal_length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                 &lt;span class=&#34;n&#34;&gt;basis_to_transform&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signal_length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signal_length&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;#  Độ dài của chuỗi đầu vào: N&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;basis_to_transform&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;basis_to_transform&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# trạng thái của véc-tơ đầu vào |j&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;np&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;signal_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Số qubit cho QFT&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Tiếp đến mình sẽ khởi tạo các qubits bằng cirq.LineQubit(). &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Các giá  trị được khởi tạo ban đầu bằng |0&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LineQubit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Khởi tạo cấu trúc mạch cho thuật toán QFT. &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Về sau các phép biến đổi sẽ được thêm vào bằng circuit.append()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;q_s&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;enumerate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;basis_to_transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;q_s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;# Nếu phần tử của véc-tơ đầu vào |j&amp;gt; khác |0&amp;gt;. &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;c1&#34;&gt;# Ta dùng NOT gate (cirq.X) để để chuyển về |0&amp;gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;input_circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;qft_circuit_iter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Lần lượt áp dụng cổng H, và phép biến đổi R_m (trong code ta có thể đơn giải hóa thành cổng CZ) &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# trên từng qubit như Hình 1.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;rotation_to_apply&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;diff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CZ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation_to_apply&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;qft_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qft_circuit_iter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Circuit after processing Qubit: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubit_index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Sử dụng cổng SWAP giữa qubit thứ m và qubits thứ n-m &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;swap_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Circuit after qubit state swap:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;swap_qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;# Sử dụng cổng SWAP giữa qubit thứ m và qubits thứ n-m &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SWAP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qubits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num_qubits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;simulate_circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;c1&#34;&gt;# Mô phỏng chương trình trên máy tính lượng tử và in ra kết quả&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;sim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cirq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Simulator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sim&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;simulate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circuit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Class &lt;em&gt;&lt;strong&gt;QFT&lt;/strong&gt;&lt;/em&gt; của mình sẽ nhận các tham số:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;signal_length&lt;/strong&gt;: Độ dài của chuỗi đầu vào&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;basis_to_transform&lt;/strong&gt;: Trạng thái của véc-tơ $\ket{j}$ đầu vào&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cấu trúc mạch của thuật toán QFT như Hình 1 được tạo ra từ hàm &lt;em&gt;&lt;strong&gt;qft_circuit()&lt;/strong&gt;&lt;/em&gt;. Ở đó các qubits lần lượt bị biến đổi theo cổng Hadamard và $\mathbf{R}_m$ được triển khai ở hàm &lt;em&gt;&lt;strong&gt;qft_circuit_iter()&lt;/strong&gt;&lt;/em&gt;. Chú ý ở đấy ta thấy phép biến đổi $\mathbf{R}_m$ bị ràng buộc vào giá trị của phần từ $j_m$ của véc-tơ đầu vào $\ket{j}$: nếu $j_m = 0$ thì $\mathbf{R}_m = I$ và không có tác động nên bài toán, phép biến đổi $\mathbf{R}_m$ chỉ có tác dụng khi và chỉ khi $j_m = 1$, khi đó:

$$
{\mathbf{R}}_m = \left( \begin{array}{cc} 1 &amp; 0 \\
0 &amp; e^{\frac{2\pi i}{2^m}} \end{array} \right) 
$$

Mặt khác ta có $e^{\pi i} = -1$

$$
\Rightarrow {\mathbf{R}}^{&#39;&#39;}_m = \left( \begin{array}{cc} 1 &amp; 0 \\
0 &amp; (-1)^{\frac{2}{2^m}} \end{array} \right) 
$$
&lt;/p&gt;
&lt;p&gt;Do đó, mình hoàn toàn đơn giản hóa phép biến đổi $\mathbf{R}_m$ bị ràng buộc bởi $j_m$ như sau:&lt;/p&gt;

$$
\left( \begin{array}{cc} I &amp; 0 \\
0 &amp; {\mathbf{R}}^{&#39;&#39;}_m \end{array} \right) = \left( \begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; (-1)^{\frac{2}{2^m}} \end{array} \right) = CZ^{\frac{2}{2^m}}.
$$

&lt;p&gt;Và tiếp đến ta có hàm &lt;em&gt;&lt;strong&gt;swap_qubits()&lt;/strong&gt;&lt;/em&gt; sẽ hoàn đổi trạng thái của lần lượt qubit thứ $m$ với $n-m$.&lt;/p&gt;
&lt;p&gt;Cuối cùng, mình có thể chạy mô phỏng chương trình này trên máy tính lượng tử với &lt;em&gt;&lt;strong&gt;cirq.Simulator()&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Với véc-tơ đầu vào $\ket{j} == \ket{0000}$ là một véc-tơ cơ sở của một chuỗi có độ dài $N = 2^4=16$. Theo như công thức (**), chúng ta mong chờ kết quả là một véc-tơ gồm 16 phần tử có giá trị $\frac{1}{4}$. Chương trình trên có kết quả như sau:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;output&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.24999997&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Có thể thấy kết quả của chương trình này hoàn toàn đúng như chúng ta đã kỳ vọng.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Mọi người có thể xem toàn bộ code của chương trình trên ở &lt;a href=&#34;https://github.com/qmlvietnam/CodeforBlog/blob/main/QFT.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;.&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Trong trường hợp này mình giả sử $\mathcal{X_N}$ đã được chuẩn hóa nhưng nó không phải là ràng buộc quá quan trọng trong trường hợp này.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Ở phần này mình sẽ không nói rõ chi tiết về cổng SWAP, mọi người có xem thêm ở &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_logic_gate#Swap_gate&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;đây&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Donate me</title>
      <link>https://example.com/donate_me/</link>
      <pubDate>Sat, 29 Oct 2022 14:54:53 +0700</pubDate>
      <guid>https://example.com/donate_me/</guid>
      <description>&lt;p&gt;Chào bạn,&lt;/p&gt;
&lt;p&gt;Cảm ơn bạn đã ghé qua blog của mình.&lt;/p&gt;
&lt;p&gt;Mình mong muốn những bài viết của mình có thể đến gần hơn tới mọi người. Khi mình viết, mình luôn cố gắng giải thích một cách dễ hiểu nhất từ các bước biến đổi toán học hay các dòng code của thuật toán đó. Mình mong muốn mọi người không chỉ hiểu lý thuyết mà còn có thể áp dụng những kiến thức đó vào trong những lĩnh vực của mọi người.&lt;/p&gt;
&lt;p&gt;Và đúng với tính chất &amp;ldquo;Prepare for the Future&amp;rdquo;, mình mong mọi người có thể ủng hộ và giúp những bài viết của mình dần dần hoàn thiện hơn, từ đó có thể tiếp cận với nhiều bạn đọc hơn nữa.&lt;/p&gt;
&lt;p&gt;Nội dung trên blog này là hoàn toàn miễn phí. Mình sẽ không sử dụng dịch vụ quảng cáo nào vì không muốn gây mất tập trung các bạn trong quá trình đọc. Tuy nhiên, nếu bạn thấy nội dung hữu ích và muốn đóng góp cho blog, bạn có thể ủng hộ blog qua một trong hai cách:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Tài khoản BIDV&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Số tài khoản: 16010000503754&lt;/p&gt;
&lt;p&gt;Chủ tài khoản: NGUYEN QUANG TUYEN&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Tài khoản Techcombank&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Số tài khoản: 19035848694011&lt;/p&gt;
&lt;p&gt;Chủ tài khoản: NGUYEN QUANG TUYEN&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mọi sự ủng hộ của các bạn đều rất trân trọng đối với mình. Mình xin chân thành cảm ơn.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mình xin chân thành cảm ơn,&lt;/p&gt;
&lt;p&gt;Nguyễn Quang Tuyến&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>October 2022</title>
      <link>https://example.com/newsletter/october-2022/</link>
      <pubDate>Sat, 29 Oct 2022 14:54:53 +0700</pubDate>
      <guid>https://example.com/newsletter/october-2022/</guid>
      <description>&lt;h1 id=&#34;news-&#34;&gt;News 📰&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.nature.com/articles/s41598-022-21607-4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Determinable and interpretable network representation for link prediction&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://cloudblogs.microsoft.com/quantum/2022/10/20/azure-quantum-credits-program-propels-quantum-innovation-and-exploration-for-researchers-educators-and-students/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Azure Quantum Credits Program propels quantum innovation and exploration for researchers, educators, and students&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.eurekalert.org/news-releases/969327&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Penn State researchers to explore using quantum computers to design new drugs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.einnews.com/pr_news/597582546/multiverse-computing-and-mila-join-forces-to-advance-artificial-intelligence-with-quantum-computing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multiverse Computing and Mila Join Forces to Advance Artificial Intelligence with Quantum Computing&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tribuneindia.com/news/brand-connect/quantum-ai-elon-musk-review-scam-app-or-legit-444921&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum AI Elon Musk Review / Scam App Or Legit?&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;videos-&#34;&gt;Videos 📽️&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=NqHKr9CGWJ0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Machine Learning Explained&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=gyU5tIppmIk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Qiskit Falll Fest CIC-IPN Mexico 2022- Quantum Machine Learning&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=zqxCnDcGSgQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Machine Learning Neuroimaging for Alzheimer’s Disease&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=6Mo0EQ7bOpg&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MLBBQ: Quantum Machine Learning by Pavel Popov&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=x6oLsJtxWzs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Machine Learning: Opportunities and Challenges&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=2rJFsxcM0N4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hands-on quantum machine learning | Rodrigo Morales | ADC2022&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=CDCiQdtOhLY&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;“Reinforcement Learning for Quantum Technologies,” presented by Florian Marquardt&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;publications-&#34;&gt;Publications 📃&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2210.07980&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Representation Theory for Geometric Quantum Machine Learning&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-0&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Recent advances in classical machine learning have shown that creating models with inductive biases encoding the symmetries of a problem can greatly improve performance. Importation of these ideas, combined with an existing rich body of work at the nexus of quantum theory and symmetry, has given rise to the field of Geometric Quantum Machine Learning (GQML). Following the success of its classical counterpart, it is reasonable to expect that GQML will play a crucial role in developing problem-specific and quantum-aware models capable of achieving a computational advantage. Despite the simplicity of the main idea of GQML &amp;ndash; create architectures respecting the symmetries of the data &amp;ndash; its practical implementation requires a significant amount of knowledge of group representation theory. We present an introduction to representation theory tools from the optics of quantum learning, driven by key examples involving discrete and continuous groups. These examples are sewn together by an exposition outlining the formal capture of GQML symmetries via &amp;ldquo;label invariance under the action of a group representation&amp;rdquo;, a brief (but rigorous) tour through finite and compact Lie group representation theory, a reexamination of ubiquitous tools like Haar integration and twirling, and an overview of some successful strategies for detecting symmetries.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2210.08566&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Theory for Equivariant Quantum Neural Networks&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-1&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Most currently used quantum neural network architectures have little-to-no inductive biases, leading to trainability and generalization issues. Inspired by a similar problem, recent breakthroughs in classical machine learning address this crux by creating models encoding the symmetries of the learning task. This is materialized through the usage of equivariant neural networks whose action commutes with that of the symmetry. In this work, we import these ideas to the quantum realm by presenting a general theoretical framework to understand, classify, design and implement equivariant quantum neural networks. As a special implementation, we show how standard quantum convolutional neural networks (QCNN) can be generalized to group-equivariant QCNNs where both the convolutional and pooling layers are equivariant under the relevant symmetry group. Our framework can be readily applied to virtually all areas of quantum machine learning, and provides hope to alleviate central challenges such as barren plateaus, poor local minima, and sample complexity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2210.09974&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Theoretical Guarantees for Permutation-Equivariant Quantum Neural Networks&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-2&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Despite the great promise of quantum machine learning models, there are several challenges one must overcome before unlocking their full potential. For instance, models based on quantum neural networks (QNNs) can suffer from excessive local minima and barren plateaus in their training landscapes. Recently, the nascent field of geometric quantum machine learning (GQML) has emerged as a potential solution to some of those issues. The key insight of GQML is that one should design architectures, such as equivariant QNNs, encoding the symmetries of the problem at hand. Here, we focus on problems with permutation symmetry (i.e., the group of symmetry Sn), and show how to build Sn-equivariant QNNs. We provide an analytical study of their performance, proving that they do not suffer from barren plateaus, quickly reach overparametrization, and can generalize well from small amounts of data. To verify our results, we perform numerical simulations for a graph state classification task. Our work provides the first theoretical guarantees for equivariant QNNs, thus indicating the extreme power and potential of GQML.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/pdf/2210.13442.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protocols for classically training quantum generative models on probability distributions&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-3&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Quantum Generative Modelling (QGM) relies on preparing quantum states and generating samples from these states as hidden - or known - probability distributions. As distributions from some classes of quantum states (circuits) are inherently hard to sample classically, QGM represents an excellent testbed for quantum supremacy experiments. Furthermore, generative tasks are increasingly relevant for industrial machine learning applications, and thus QGM is a strong candidate for demonstrating a practical quantum advantage. However, this requires that quantum circuits are trained to represent industrially relevant distributions, and the corresponding training stage has an extensive training cost for current quantum hardware in practice. In this work, we propose protocols for classical training of QGMs based on circuits of the specific type that admit an efficient gradient computation, while remaining hard to sample. In particular, we consider Instantaneous Quantum Polynomial (IQP) circuits and their extensions. Showing their classical simulability in terms of the time complexity, sparsity and anti-concentration properties, we develop a classically tractable way of simulating their output probability distributions, allowing classical training to a target probability distribution. The corresponding quantum sampling from IQPs can be performed efficiently, unlike when using classical sampling. We numerically demonstrate the end-to-end training of IQP circuits using probability distributions for up to 30 qubits on a regular desktop computer. When applied to industrially relevant distributions this combination of classical training with quantum sampling represents an avenue for reaching advantage in the NISQ era.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2210.11850&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Universal algorithms for quantum data learning&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-4&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Operating quantum sensors and quantum computers would make data in the form of quantum states available for purely quantum processing, opening new avenues for studying physical processes and certifying quantum technologies. In this Perspective, we review a line of works dealing with measurements that reveal structural properties of quantum datasets given in the form of product states. These algorithms are universal, meaning that their performances do not depend on the reference frame in which the dataset is provided. Requiring the universality property implies a characterization of optimal measurements via group representation theory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2209.05523&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Generalization despite overfitting in quantum machine learning models&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-5&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;The widespread success of deep neural networks has revealed a surprise in classical machine learning: very complex models often generalize well while simultaneously overfitting training data. This phenomenon of benign overfitting has been studied for a variety of classical models with the goal of better understanding the mechanisms behind deep learning. Characterizing the phenomenon in the context of quantum machine learning might similarly improve our understanding of the relationship between overfitting, overparameterization, and generalization. In this work, we provide a characterization of benign overfitting in quantum models. To do this, we derive the behavior of a classical interpolating Fourier features models for regression on noisy signals, and show how a class of quantum models exhibits analogous features, thereby linking the structure of quantum circuits (such as data-encoding and state preparation operations) to overparameterization and overfitting in quantum models. We intuitively explain these features according to the ability of the quantum model to interpolate noisy data with locally &amp;ldquo;spiky&amp;rdquo; behavior and provide a concrete demonstration example of benign overfitting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://arxiv.org/abs/2209.14353&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Interpretable Quantum Advantage in Neural Sequence Learning&lt;/a&gt;
&lt;details class=&#34;spoiler &#34;  id=&#34;spoiler-6&#34;&gt;
  &lt;summary&gt;Abstract:&lt;/summary&gt;
  &lt;p&gt;&lt;blockquote&gt;
&lt;p&gt;Quantum neural networks have been widely studied in recent years, given their potential practical utility and recent results regarding their ability to efficiently express certain classical data. However, analytic results to date rely on assumptions and arguments from complexity theory. Due to this, there is little intuition as to the source of the expressive power of quantum neural networks or for which classes of classical data any advantage can be reasonably expected to hold. Here, we study the relative expressive power between a broad class of neural network sequence models and a class of recurrent models based on Gaussian operations with non-Gaussian measurements. We explicitly show that quantum contextuality is the source of an unconditional memory separation in the expressivity of the two model classes. Additionally, as we are able to pinpoint quantum contextuality as the source of this separation, we use this intuition to study the relative performance of our introduced model on a standard translation data set exhibiting linguistic contextuality. In doing so, we demonstrate that our introduced quantum models are able to outperform state of the art classical models even in practice.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/p&gt;
&lt;/details&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bài 2: Quantum Squared-Distance Classifier</title>
      <link>https://example.com/post/example-1/</link>
      <pubDate>Tue, 11 Oct 2022 23:25:52 +0700</pubDate>
      <guid>https://example.com/post/example-1/</guid>
      <description>&lt;meta property=&#34;og:image&#34; content=&#34;/post/example-1/featured.jpg&#34;&gt;
&lt;meta property=&#34;og:image:type&#34; content=&#34;image/jpeg&#34;&gt;
&lt;meta property=&#34;og:image:width&#34; content=&#34;200&#34;&gt;
&lt;meta property=&#34;og:image:height&#34; content=&#34;200&#34;&gt;
&lt;p&gt;Trong bài này, mình đi qua một phương pháp xử lý bài toán &lt;em&gt;nearest neighbour&lt;/em&gt; bằng thuật toán quantum. Bài viết dưới đây sẽ dựa vào bài báo gốc: &lt;a href=&#34;https://arxiv.org/pdf/1703.10793.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Implementing a distance-based classifier with a quantum interference circuit&lt;/a&gt;, nếu ai muốn tìm hiểu sâu hơn về ý tưởng này thì có thể ghé qua.&lt;/p&gt;
&lt;h1 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Squared-Distance Classifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Quantum Squared-Distance Classifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Kết luận&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;Source Code&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;squared-distance-classifier-a-name1a&#34;&gt;Squared-Distance Classifier &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Ở đây, mình xét ví dụ bài toán phân loại tập data &lt;a href=&#34;https://www.kaggle.com/c/titanic&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Titanic&lt;/a&gt;. Giả sử tập data được biểu diễn dưới dạng:&lt;/p&gt;

$$
\mathcal{D} = \Big\{ ({\bf{x}}^1, y^1), \ldots ({\bf{x}}^M , y^M)  \Big\},
$$

&lt;p&gt;trong đó các véc-tơ đầu vào 2 chiều: ${ {\bf{x}}^m = ({x_0}^m, {x_1}^m)^T}, m = 1,2,&amp;hellip;,M$ tượng trưng cho một hành khách trên chuyến tàu Titanic đã bị nhấn chìm vào năm 1912. Trong đó $x_0$ là giá vé trong khoảng từ 0 đến 10,000 đô la, và $x_1$ là số hiệu cabin trong khoảng từ 1 đến 2,500. Ứng với mỗi một véc-tơ đầu vào là nhãn $y^m = {0,1}$ tương ứng để chỉ ra hành khách đó đã sống sót hay không.&lt;/p&gt;
















&lt;figure  id=&#34;figure-soucehttpslinkspringercombook101007978-3-319-96424-9&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Souce](https://link.springer.com/book/10.1007/978-3-319-96424-9)&#34; srcset=&#34;
               /post/example-1/data_hu78303baaf7a0b85d6e4300342c9fda14_45037_631af45315bba8601596423120b56c6c.webp 400w,
               /post/example-1/data_hu78303baaf7a0b85d6e4300342c9fda14_45037_3666c6daa3fe241e15be294f70efc0e8.webp 760w,
               /post/example-1/data_hu78303baaf7a0b85d6e4300342c9fda14_45037_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/example-1/data_hu78303baaf7a0b85d6e4300342c9fda14_45037_631af45315bba8601596423120b56c6c.webp&#34;
               width=&#34;760&#34;
               height=&#34;183&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;https://link.springer.com/book/10.1007/978-3-319-96424-9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Souce&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Nếu từng tìm hiểu qua về Machine Learning, chắc hẳn các bạn đã nghe hoặc đọc qua về thuật toán &lt;em&gt;nearest neighbour&lt;/em&gt;: với mỗi véc-tơ đầu vào mới, thì nhãn của nó sẽ được quyết định bởi điểm dữ liệu gần nhất với nó. Có nhiều cách để xác định những điểm dữ liệu gần nhất đó nhưng phổ biến là &lt;a href=&#34;https://en.wikipedia.org/wiki/Euclidean_distance&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Euclidean distance&lt;/a&gt;. Do vậy, ta có cách tính hệ số cho việc gán nhãn véc-tơ $\tilde{x}$ mới theo nhãn của $x^m$:

$$
\gamma_m = 1-\frac{1}{c}|\tilde{{\bf x}}-{\bf x}^m|^2, 
$$

trong đó $c$ là hằng số. Hệ số càng cao chứng tỏ $\tilde{{\bf x}}$ càng gần $x^m$. Gọi $\tilde{y}$ là nhãn được gán cho $\tilde{{\bf x}}$, ta có xác xuất $p_{\tilde{{\bf x}}}(\tilde{y}=1)$ là tổng trung bình hệ số của $M_1$ điểm dữ liệu mà có nhãn là $1$:

$$
p_{\tilde{{\bf x}}}(\tilde{y}=1) = \frac{1}{\chi}\frac{1}{M_1} \sum_{m|y^m=1}(1-\frac{1}{c}|\tilde{{\bf x}}-{\bf x}^m|^2) 
$$

Tương tự như vậy,  $p_{\tilde{{\bf x}}}(\tilde{y}=0)$ là tổng trung bình hệ số của các điểm dữ liệu mà có nhãn là $0$. Trong đó $\frac{1}{\chi}$ là &lt;em&gt;normalizing factor&lt;/em&gt; sao cho $p_{\tilde{{\bf x}}}(\tilde{y}=0)+p_{\tilde{{\bf x}}}(\tilde{y}=1)=1$.&lt;/p&gt;
















&lt;figure  id=&#34;figure-soucehttpslinkspringercombook101007978-3-319-96424-9&#34;&gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;[Souce](https://link.springer.com/book/10.1007/978-3-319-96424-9)&#34; srcset=&#34;
               /post/example-1/visualization_hu16f5b777f6d9f46571da58af462c2aaf_44927_fe9e1f90176d7b9290d6772978090665.webp 400w,
               /post/example-1/visualization_hu16f5b777f6d9f46571da58af462c2aaf_44927_96d167ef3597b0fad12f14d6ffd877df.webp 760w,
               /post/example-1/visualization_hu16f5b777f6d9f46571da58af462c2aaf_44927_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/example-1/visualization_hu16f5b777f6d9f46571da58af462c2aaf_44927_fe9e1f90176d7b9290d6772978090665.webp&#34;
               width=&#34;760&#34;
               height=&#34;263&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;figcaption&gt;
      &lt;a href=&#34;https://link.springer.com/book/10.1007/978-3-319-96424-9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Souce&lt;/a&gt;
    &lt;/figcaption&gt;&lt;/figure&gt;
&lt;p&gt;Áp dụng phương pháp ta thấy &lt;em&gt;Passenger 3&lt;/em&gt; sẽ gần với &lt;em&gt;Passenger 1&lt;/em&gt; hơn so với &lt;em&gt;Passenger 2&lt;/em&gt; (Fig 1.2), và mô hình sẽ đưa ra dự đoán là $1$ tương ứng với &lt;em&gt;survival&lt;/em&gt;.&lt;/p&gt;
&lt;h1 id=&#34;quantum-squared-distance-classifier-a-name2a&#34;&gt;Quantum Squared-Distance Classifier &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Giờ hãy xử lý bài toàn này bằng phương pháp &amp;lsquo;quantum&amp;rsquo;.&lt;/p&gt;
&lt;h2 id=&#34;bước-1-data-preprocessing-and-encoding&#34;&gt;Bước 1: Data preprocessing and Encoding&lt;/h2&gt;
&lt;p&gt;Đầu tiên chúng ta sẽ đi tới một câu hỏi kinh điển &amp;ldquo;Làm sao có thể biểu diễn dữ liệu trên máy tính lượng tử?&amp;rdquo;. Nếu như trên máy tính truyền thống các thông tin như ảnh sẽ thường được biển diễn trên không gian RBG có giá trị từ 0 đến 255, hay chúng ta có &lt;a href=&#34;https://en.wikipedia.org/wiki/Word_embedding&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Word Embedding&lt;/a&gt; để biểu thông tin dạng văn bản thành các véc-tơ, thì vấn đề của các thuật toán lượng tử cũng như vậy. Thực chất, chủ đề về việc mã hóa thông tin trên không gian lượng tử (&lt;em&gt;Quantum Embedding&lt;/em&gt;) vẫn đang được cộng đồng nghiên cứu quan tâm đặc biệt trong lĩnh vực Quantum Machine Learning. Nếu các bạn quan tâm đến chủ đề này có thể xem qua &lt;a href=&#34;https://arxiv.org/abs/2001.03622&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;paper&lt;/a&gt; này để biết rõ hơn về các cách mã thông tin trong QML và sự quan trọng của nó. Mình sẽ làm một bài viết chi tiết hơn về chủ đề này trong tương lai.&lt;/p&gt;
&lt;p&gt;Quay lại với bài toán của chúng ta, mình sẽ áp dụng một phương pháp gọi là &lt;em&gt;Amplitude Embedding&lt;/em&gt; - một phương pháp rất phố biến trong QML: Cho $X \in \mathbb{R}^N$ là một véc-tơ đơn nhất ($||X|| = 1$), ta có thể mã hóa $X$ bằng $n$ qubits dưới dạng:

$$
\ket{\psi_X} = \sum_{i=0}^{N-1}x_i \ket{i},
$$

trong đó $n = \log{N}$. Có thể thấy phương pháp này chỉ tốn $O(\log{N})$ qubits để biểu diễn một véc-tơ $N$ chiều. Hãy lấy ví dụ trong bài toán xử lý ngôn ngữ tự nhiên, giả sử bạn có một &lt;em&gt;text corpus&lt;/em&gt; với 10000 từ thì nếu như cách thông thường ta sử dụng &lt;a href=&#34;https://en.wikipedia.org/wiki/One-hot&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;One-hot encoding&lt;/a&gt; ta sẽ cần tới 10000 bits để mã hóa, nhưng điều này hoàn toán có thể giải quyết với 14 ($\lceil \log{10000} \rceil$) qubits với amplitude embedding.&lt;/p&gt;
&lt;p&gt;Từ đây, với mỗi đầu vào $\ket{\psi_{\bf\tilde{x}}}$ mới, bài toán sẽ được khởi tạo dưới dạng:&lt;/p&gt;
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/example-1/equation1_hu895413c6cafbee8ea8735175e11f8b65_165324_c12a5c7ac1ed347a463e9f71fb60f756.webp 400w,
               /post/example-1/equation1_hu895413c6cafbee8ea8735175e11f8b65_165324_3f31152c28be40d0d2c5e116e940fd8b.webp 760w,
               /post/example-1/equation1_hu895413c6cafbee8ea8735175e11f8b65_165324_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://example.com/post/example-1/equation1_hu895413c6cafbee8ea8735175e11f8b65_165324_c12a5c7ac1ed347a463e9f71fb60f756.webp&#34;
               width=&#34;760&#34;
               height=&#34;202&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;Trong đó $\ket{m}$ và $\ket{y^m}$ mã hóa cho số thứ tự và nhãn tương ứng của véc-tơ đầu vào thứ $m^{th}$. Tuy nhiên điều chú ý ở đây nằm ở &lt;em&gt;ancilla qubit&lt;/em&gt; được kết nối với $\ket{\psi_{\bf\tilde{{x}}}}$ và $\ket{\psi_{\bf{x}^m}}$. Chú ý rằng khi ta thực hiện phép do trên một hoặc một hệ qubits thì qubit(s) sẽ bị &lt;em&gt;collapsed&lt;/em&gt; hay &lt;em&gt;terminated&lt;/em&gt;. Vậy khi ta chuyển phép đo của $\ket{\psi_{\bf\tilde{{x}}}}$ hay $\ket{\psi_{\bf{x}^m}}$ sang phép đo của một &lt;em&gt;ancilla qubit&lt;/em&gt; được kết nối với chúng thì ta vẫn thu được kết quả cần thiết của $\ket{\psi_{\bf\tilde{{x}}}}$ và $\ket{\psi_{\bf{x}^m}}$ mà không cần chấm dứt (&lt;em&gt;terminate&lt;/em&gt;) cả hệ thống. Kỹ thuật này rất hay sử dụng ở trong các thuật toán lượng tử và việc kết nối giữa &lt;em&gt;ancilla qubit&lt;/em&gt; với hệ thống là chúng ta đang tạo ra &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_entanglement&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;entanglement&lt;/em&gt;&lt;/a&gt; - một tính chất quan trọng khác trong lĩnh vực tính toán lượng tử.&lt;/p&gt;
&lt;p&gt;Như vậy với ví dụ Titanic trên ta có:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/example-1/data_processing_hu8c90f3f68a6d31a7f4dad34dc8d04642_53301_06417e8dac8b40de76662264a3b79f5c.webp 400w,
               /post/example-1/data_processing_hu8c90f3f68a6d31a7f4dad34dc8d04642_53301_a62954af2ee2bbe430771a386cb5b63b.webp 760w,
               /post/example-1/data_processing_hu8c90f3f68a6d31a7f4dad34dc8d04642_53301_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://example.com/post/example-1/data_processing_hu8c90f3f68a6d31a7f4dad34dc8d04642_53301_06417e8dac8b40de76662264a3b79f5c.webp&#34;
               width=&#34;760&#34;
               height=&#34;348&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;

$$
\ket{\mathcal{D}} = \frac{1}{\sqrt{4}} \Big\{\ket{0}[\ket{0}(0.866\ket{0}+0.5\ket{1})+\ket{1}(0.921\ket{0}+0.39\ket{1})]\ket{1}
$$
&lt;/p&gt;

$$
+ \ket{1}[\ket{0}(0.866\ket{0}+0.5\ket{1})+\ket{1}(0.141\ket{0}+0.99\ket{1})]\ket{0} \Big\}
$$

&lt;h2 id=&#34;bước-2-áp-dụng-biến-đổi-hadamard&#34;&gt;Bước 2: Áp dụng biến đổi Hadamard&lt;/h2&gt;
&lt;p&gt;Như mình đề cập tới bài viết trước, hầu hết các biến đổi trên máy tính lượng tử là tuyên tính nên việc thực hiện các phép biến đổi là các phép nhân với ma trận biểu diễn tương ứng. Ở đây, ma trận Hadamard có dạng:

$$
H = \frac{1}{\sqrt{2}}\left( \begin{array}{cc} 1 &amp; 1 \\
1 &amp; -1 \end{array} \right)
$$
&lt;/p&gt;
&lt;p&gt;Như vậy, nếu ta áp dụng biến đổi Hadamard cho &lt;em&gt;ancilla qubit&lt;/em&gt; ta có:&lt;/p&gt;

$$
\ket{\mathcal{D}} \longrightarrow \frac{1}{\sqrt{2M}} \sum_{m=0}^{M-1} \ket{m}\Big(H\ket{0}\ket{\psi_{\bf\tilde{{x}}}} + H\ket{1}\ket{\psi_{\bf{x}^m}}\Big)\ket{y^m}
$$

&lt;p&gt;Với những bạn đã đọc qua &lt;a href=&#34;https://example.com/post/fair-coins&#34;&gt;Bài 1&lt;/a&gt; hoặc với một chút tính toán, chúng ta dễ dàng chứng minh được:

$$
H\ket{0} = \frac{1}{\sqrt{2}}(\ket{0}+\ket{1}), H\ket{1} = \frac{1}{\sqrt{2}}(\ket{0}-\ket{1}) 
$$

Áp dụng công thức trên, ta được:

$$
\ket{\mathcal{D}}\! \longrightarrow\! \frac{1}{2\sqrt{M}} \sum_{m=0}^{M-1} \ket{m}\Big(\ket{0}(\ket{\psi_{\bf\tilde{{x}}}}+\ket{\psi_{\bf{x}^m}}) + \ket{1}(\ket{\psi_{\bf\tilde{{x}}}}-\ket{\psi_{\bf{x}^m}})\Big)\ket{y^m}
$$
&lt;/p&gt;
&lt;h2 id=&#34;bước-3-phép-đo&#34;&gt;Bước 3: Phép đo&lt;/h2&gt;
&lt;p&gt;Ở đây ta sẽ cần sử dụng lần lượt 2 phép đo trên &lt;em&gt;ancilla qubit&lt;/em&gt; và $\ket{y^m}$. Nhưng trước đó mình sẽ viết lại kết quả thu được sau bước 2:

$$ 
\frac{1}{2\sqrt{M}} \sum_{m=0}^{M-1} \ket{m}\Big(\ket{0}\sum_{i=0}^{N} ({\tilde{{\bf{x}}}}^m_i+{\bf{x}}^m_i)\ket{i} + \ket{1}\sum_{i=0}^{N} ({\tilde{{\bf{x}}}}^m_i-{\bf{x}}^m_i)\ket{i}\Big)\ket{y^m} 
$$
&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1. Phép đo trên ancilla qubit&lt;/em&gt;: Ở phép đó này, ta sẽ có xác suất $p_0 = \Big(\frac{1}{2\sqrt{M}} \sum_{m=0}^{M-1}\sum_{i=0}^{N} ({\tilde{{\bf{x}}}}^m_i+{\bf{x}}^m_i)\Big)^2 = \frac{1}{4M}\sum_M|{\bf\tilde{x}}+{\bf x}^m|^2$ thu được kết quả là $0$ và tương tự ta thu được kết quả 1 từ &lt;em&gt;ancilla qubit&lt;/em&gt; với xác suất $p_1=\frac{1}{4M}\sum_M|{\bf\tilde{x}}-{\bf x}^m|^2$. Tuy nhiên ở đây ta sẽ chỉ lấy kết quả thu được nếu &lt;em&gt;ancilla qubit&lt;/em&gt; có giá trị là $0$, hay nói cách khác ta &lt;em&gt;terminate&lt;/em&gt; nhánh mà &lt;em&gt;ancilla qubit&lt;/em&gt; có trạng thái là $\ket{1}$, ta có:

$$ 
\frac{1}{2\sqrt{Mp_0}} \sum_{m=0}^{M-1} \ket{m}\Big(\ket{0}\sum_{i=0}^{N} ({\tilde{{\bf{x}}}}^m_i+{\bf{x}}^m_i)\ket{i} \Big)\ket{y^m} 
$$
&lt;/p&gt;
&lt;p&gt;Ta nhân $p_0$ ở đây để chắc chắn rằng hệ thống của chúng ta vẫn là đơn nhất (&lt;em&gt;unit length&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2. Phép đo trên $\ket{y^m}$&lt;/em&gt;
Ta có thể dễ dàng thấy xác suất thu được có giá trị bằng $0$ là:

$$ 
p(y=0) = \frac{1}{4Mp_0}\sum_{m|y^m=0}|{\tilde{{\bf{x}}}+{\bf{x}}^m}|^2
$$
&lt;/p&gt;
&lt;p&gt;Vì $\tilde{{\bf{x}}}$ hay ${{\bf{x}}}^m$ là đơn nhất nên ta hoàn toàn có thể chứng minh được:&lt;/p&gt;

$$ 
\frac{1}{4Mp_0}\sum_{m|y^m=0}|{\tilde{{\bf{x}}}+{\bf{x}}^m}|^2 = 1 - \frac{1}{4Mp_0}\sum_{m|y^m=0}|{\tilde{{\bf{x}}}-{\bf{x}}^m}|^2
$$

&lt;p&gt;Bài toán sẽ được hoàn toàn đưa về giống với kết quả trường hợp trên máy tính truyền thống mà mình đề cập tới ở trên.&lt;/p&gt;
&lt;p&gt;Ta áp dụng bài toán của tập Titanic vào công thức trên ta được:

$$ 
p(y=0) = \frac{1}{4Mp_0}(|0.141+0.866|^2+|0.990+0.5|^2)  \approx 0.448, 
$$
&lt;/p&gt;

$$ 
p(y=1) = \frac{1}{4Mp_0}(|0.921+0.866|^2+|0.390+0.5|^2)  \approx 0.552, 
$$

&lt;p&gt;Như vậy có thể thấy kết quả thu được từ thuật toán lượng tử này cũng cho ra kết quả rằng &lt;em&gt;Passenger 3&lt;/em&gt; sẽ sống sót.&lt;/p&gt;
&lt;h1 id=&#34;kết-luận-a-name3a&#34;&gt;Kết luận &lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Có thể thấy chúng ta hoàn toàn có thể xây dựng một thuật toán lượng tử tương đương trong bài toán &lt;em&gt;distanced-based classifier&lt;/em&gt;. Mặc dù ví dụ trên chưa cho chúng ta thấy được &lt;em&gt;quantum advantage&lt;/em&gt; nhưng nó giúp mọi người hiểu được cấu trúc chung của một thuật toán lượng tử nói chung và mô hình trong QML nói riêng: Mã hóa (embedding) -&amp;gt; Các phép biến đổi (Transformations) -&amp;gt; Phép đo (Measurement).&lt;/p&gt;
&lt;h1 id=&#34;source-code-a-name4a&#34;&gt;Source Code &lt;a name=&#34;4&#34;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Mã nguồn trong bài này có thể được tìm thấy &lt;a href=&#34;https://github.com/qmlvietnam/CodeforBlog/blob/main/classifier.ipynb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tại đây&lt;/a&gt;.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Bài 1: Quantum vs Classical Interference: First Example</title>
      <link>https://example.com/post/fair-coins/</link>
      <pubDate>Sun, 09 Oct 2022 14:41:26 +0700</pubDate>
      <guid>https://example.com/post/fair-coins/</guid>
      <description>&lt;meta property=&#34;og:image&#34; content=&#34;/post/fair-coins/featured.jpg&#34;&gt;
&lt;meta property=&#34;og:image:type&#34; content=&#34;image/jpeg&#34;&gt;
&lt;meta property=&#34;og:image:width&#34; content=&#34;200&#34;&gt;
&lt;meta property=&#34;og:image:height&#34; content=&#34;200&#34;&gt;
&lt;h2 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Giới thiệu bài toán&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Classical Interference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Quantum Interference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4&#34;&gt;Kết luận&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Trước khi đi vào các thuật toán quantum trong học máy, mình muốn so sánh bài toán suy luận xác suất trên máy tính truyền thống cũng như trên máy tính lượng tử. Bài viết này sẽ giúp các bạn viết qua những thành phần cơ bản của vật lý lượng tử: &lt;em&gt;&lt;a href=&#34;https://vi.wikipedia.org/wiki/Qubit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;qubits&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Unitary_transformation_%28quantum_mechanics%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;unitary transformation&lt;/a&gt;&lt;/em&gt;, và &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;measurement&lt;/a&gt;&lt;/em&gt; và cách hoạt động của chúng thông qua một ví dụ cụ thể.&lt;/p&gt;
&lt;h2 id=&#34;giới-thiệu-bài-toán-a-name1a&#34;&gt;Giới thiệu bài toán &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Cho hai đồng xu đồng chất: $c_1$ và $c_2$ với xác suất ở mặt sấp (&lt;em&gt;tail&lt;/em&gt;) hay mặt ngửa (&lt;em&gt;head&lt;/em&gt;) là như nhau. Không gian mẫu của việc tung 2 đồng xu trên sẽ bao gồm: &lt;em&gt;(head, head)&lt;/em&gt;, &lt;em&gt;(head, tail)&lt;/em&gt;, &lt;em&gt;(tail, head)&lt;/em&gt;, và &lt;em&gt;(tail, tail)&lt;/em&gt;. Mình sẽ xét bài toán như sau: Bước 1, ta lật 2 đồng xu thành mặt ngửa (&lt;em&gt;head&lt;/em&gt; sẽ là giá trị ban đầu của 2 đống xu). Bước 2, ta tung đồng xu thứ nhất $c_1$ và kiểm tra kết quả. Và bước 3, ta cũng lại tung đồng xu $c_1$ lần thứ hai và kiểm tra kết quả (giả sử kết quả thu được là sau số lần thử đủ lớn).&lt;/p&gt;
&lt;h2 id=&#34;classical-interference-suy-luận-xác-suất-truyền-thống-a-name2a&#34;&gt;Classical Interference (Suy luận xác suất truyền thống) &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Có thể thấy với máy tính truyền thống (&lt;em&gt;classical computer&lt;/em&gt;), 2 đồng xu có thể được coi là 2 bits ngẫu nhiên (&lt;em&gt;random bits&lt;/em&gt;). Ở bước 1, bài toán sẽ đưa về kết quả &lt;em&gt;(head, head)&lt;/em&gt;. Tuy nhiên, sau bước hai thì &lt;em&gt;(head, head)&lt;/em&gt; và &lt;em&gt;(tail, head)&lt;/em&gt; sẽ có xác suất bằng nhau và bằng 0.5. Phân phối này sẽ không thay đổi sau bước 3.&lt;/p&gt;
&lt;h2 id=&#34;quantum-interference-suy-luận-xác-suất-trên-máy-tính-quantum-a-name3a&#34;&gt;Quantum Interference (Suy luận xác suất trên máy tính quantum) &lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Tuy nhiên, ở đây sẽ có một chút khác biệt nếu ta biểu diễn bài toán trên máy tính quantum. Hai đồng xu sẽ được biểu diễn bằng hai &lt;em&gt;&lt;a href=&#34;https://vi.wikipedia.org/wiki/Qubit&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;qubits&lt;/a&gt;&lt;/em&gt; (quantum bits). Mỗi qubit có dạng $\alpha \ket{0} + \beta \ket{1}$, trong đó $\ket{0}$ và $\ket{1}$ là hai trạng thái cơ sở (&lt;em&gt;basis state&lt;/em&gt;) được biểu diễn dưới dạng véc-tơ tương ứng: $[1,0]^T$ và $[0,1]^T$. Có thể thấy rằng $\ket{0}$ và $\ket{1}$ tương ứng với hai giá trị nhị phân 0, 1 ở máy tính truyền thống; tuy nhiên, thay vì được mã hóa rời rạc thành chuỗi bit 1 hoặc 0, mỗi &lt;em&gt;qubit&lt;/em&gt; có thể tạo thành một tổ hợp tuyến tính của các trạng thái cơ sở theo xác suất:

$$
p(0) = |\alpha|^2, p(1) = |\beta|^2; \alpha, \beta \in \mathbb{C}
$$
 &lt;br&gt;
Chú ý rằng $|\alpha|^2 + |\beta|^2 = 1$ để thỏa mãn xác suất trên. Như vậy nếu ta coi hai mặt của đồng xu là hai trạng thái cơ sở: $\ket{head} = \ket{0}$ và $\ket{tail} = \ket{1}$, thì việc tung đồng xu sẽ tương đương việc chúng ta thực hiện biến đổi &lt;a href=&#34;https://en.wikipedia.org/wiki/Hadamard_transform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hadamard&lt;/a&gt;. Việc biến đổi ở đây trên máy tính quantum chính là phép nhân ma trận Hadamard với trạng thái hiện tại của qubit. Trong đó biến đổi Hadamard có thể được biểu diễn dưới dạng ma trận:&lt;/p&gt;

$$
H = \frac{1}{\sqrt{2}}\left( \begin{array}{cc} 1 &amp; 1 \\
1 &amp; -1 \end{array} \right)
$$

&lt;p&gt;Từ đó, ta có thể triển khai bài toán trên như sau: 2 qubits sẽ được khởi tạo thành $\ket{head}\ket{head}$ sau bước 1. Ở bước 2, ta nhân ma trận Hadamard với trạng thái của qubit thứ nhất, ta có:

$$
  H\ket{head}\ket{head}= H\ket{0}\ket{head} = \frac{1}{\sqrt{2}}\left( \begin{array}{cc} 1 &amp; 1 \\
1 &amp; -1 \end{array} \right) \left( \begin{array}{c} 1 \\ 0 \end{array} \right) \ket{head}   
$$


$$
=\!\frac{1}{\sqrt{2}}\left( \begin{array}{c} 1 \\ 1 \end{array} \right)\! \ket{head}\! =\! \frac{1}{\sqrt{2}} (\ket{0}\!+\!\ket{1})\!\ket{head}\! =\! \frac{1}{\sqrt{2}} (\ket{head}\!+\!\ket{tail})\!\ket{head}
$$


$$
= \frac{1}{\sqrt{2}}\ket{head}\ket{head} + \frac{1}{\sqrt{2}}\ket{tail}\ket{head}   
$$

Như vậy, ta thấy giống như trường hợp trên, sau bước 2 xác suất đạt được $\ket{head}\ket{head}$ và $\ket{tail}\ket{head}$ là bằng nhau là cũng bằng $(\frac{1}{\sqrt{2}})^2 = 0.5$. Tuy nhiên sự khác biệt nằm ở bước 3, nếu ta tiếp tục tung đồng xu thứ nhất (hay thực hiện biến đổi Hadamard), với một chút tính toán ta nhận được kết quả:&lt;/p&gt;
&lt;p&gt;
$$
\frac{1}{\sqrt{2}}H\ket{head}\ket{head} + \frac{1}{\sqrt{2}}H\ket{tail}\ket{head} = \ket{head}\ket{head}   
$$

Sau bước 3 ta sẽ luôn nhận được $\ket{head}\ket{head}$, kết quả này khác hoàn toán khi thực hiện bài toán trên máy tính truyền thống. Có thể nói đây là một sự khác nhau thú vị giữa máy tính lượng tử và máy tính truyền thống. Khác với máy tính truyền thống có xu hướng tối đa hóa sự không chắc chắn (&lt;em&gt;maximize uncertainty&lt;/em&gt;) vì luôn cho ra kết quả 50-50 giữa 2 trạng thái (head, head) và (tail, head), thì máy tính lượng tử cho ra kết quả có độ không chắc chắn thấp hơn. Chính vì lý do này, đã có nghiên cứu áp dụng &lt;em&gt;quantum inference&lt;/em&gt; như một hàm dự đoán (prediction function) trong bài toán học máy có giám sát (supervised learning) [&lt;a href=&#34;https://arxiv.org/abs/2004.01227&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;1&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;Sự khác nhau trên cũng dẫn ta tới một vấn đề quan trọng khác: &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;measurement&lt;/a&gt;&lt;/em&gt; (phép đo). Phép đo chính là cầu nối giữa &lt;em&gt;quantum&lt;/em&gt; và &lt;em&gt;classical&lt;/em&gt;, giúp chúng ta đánh giá và phân tích trạng thái hiện tại của một hoặc một hệ qubit, và nó thường mang tính thống kê xác suất hơn là một đánh giá đơn lẻ. Nói cách khác, phép đo cho phép chúng ta phá bỏ tính chống chât của qubits (phá bỏ đi tổ hợp tuyến tính), từ đó làm cho trạng thái của qubit &lt;em&gt;&amp;lsquo;collapse&amp;rsquo;&lt;/em&gt; về một trong các trạng thái cơ sở. Ví dụ, thực hiện phép đo một qubit bất kỳ $\ket{\phi} = \alpha \ket{0} + \beta \ket{1}$ trên cơ sở chuẩn (&lt;em&gt;canonical basis&lt;/em&gt;) thì ta sẽ đạt được giá trị 0 với xác suất là $|\alpha|^2$ và giá trị 1 với xác suất $|\beta|^2$. Kết quả thu được từ phép đo sẽ là một thống kê xác suất.&lt;/p&gt;
&lt;p&gt;Giờ mình sẽ triển khai lại bài toán trên nếu ta thực hiện phép đo giữa bước 2 và bước 3. Sau bước 2, trạng thái của 2 đồng xu có dạng: $\frac{1}{\sqrt{2}}\ket{head}\ket{head} + \frac{1}{\sqrt{2}}\ket{tail}\ket{head}$. Nếu ta thực hiện phép đo ở đây, ta có 50% thu được $\ket{head}\ket{head}$ và 50% thu được $\ket{tail}\ket{head}$. Do đó ở bước 3 ta xét hai trường hợp:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Trường hợp I:

$$
H\ket{head}\ket{head} = \frac{1}{\sqrt{2}}\ket{head}\ket{head} + \frac{1}{\sqrt{2}}\ket{tail}\ket{head}   
$$
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trường hợp II:

$$
H\ket{tail}\ket{head} = \frac{1}{\sqrt{2}}\ket{head}\ket{head} - \frac{1}{\sqrt{2}}\ket{tail}\ket{head}   
$$
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Có thể thấy ở hai trường hợp thì sau bước 3 đều cho ra trạng thái $\ket{head}\ket{head}$ hay $\ket{tail}\ket{head}$ với xác suất $(\pm\frac{1}{\sqrt{2}})^2 = 0.5$ và sẽ giống với kết quả của máy tính truyền thống.&lt;/p&gt;
&lt;h2 id=&#34;kết-luận-a-name4a&#34;&gt;Kết luận &lt;a name=&#34;4&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Trên đây, mình đã đưa ra ví dụ so sánh khả năng suy luận xác suất của máy tính truyền thống và máy tính lượng tử. Ngoài ra mình giới thiệu sơ bộ về thành phần cơ bản trong vật lý lượng tử như qubits, cách triển khai phép biến đổi, và phép đo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Khác với máy tính truyền thống có xu hướng tối đa hóa sự không chắc chắn, thì máy tính lượng tử cho ra kết quả có độ không chắc chắn thấp hơn.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qubit có dạng tổ hợp tuyến tính của các trạng thái cơ sở dựa theo một xác suất.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trong máy tính lượng tử, phép biến đổi là phép nhân ma trận tương ứng với trạng thái hiện tại của qubit.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Phép đo là cầu nối giữa &lt;em&gt;&amp;lsquo;quantum&amp;rsquo;&lt;/em&gt; và &lt;em&gt;&amp;lsquo;classical&amp;rsquo;&lt;/em&gt; phá bỏ đi tính chồng chất của một hoặc một hệ qubits và cho ra kết quả là một thống kê xác suất.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Bài 0: Giới thiệu về Quantum Machine Learning</title>
      <link>https://example.com/post/why-qml/</link>
      <pubDate>Fri, 30 Sep 2022 22:37:50 +0700</pubDate>
      <guid>https://example.com/post/why-qml/</guid>
      <description>&lt;meta property=&#34;og:image&#34; content=&#34;/post/why-qml/featured.jpg&#34;&gt;
&lt;meta property=&#34;og:image:type&#34; content=&#34;image/jpeg&#34;&gt;
&lt;meta property=&#34;og:image:width&#34; content=&#34;200&#34;&gt;
&lt;meta property=&#34;og:image:height&#34; content=&#34;200&#34;&gt;
&lt;h2 id=&#34;nội-dung&#34;&gt;Nội dung&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;#1&#34;&gt;Quantum Machine Learning là gì?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2&#34;&gt;Một vài hướng tiếp cận của Quantum Machine Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3&#34;&gt;Kết luận&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Khác với các chủ đề của Machine Learning hay Deep Learning khi mà các ứng dụng của chúng đang dần trở nên phổ biến những năm gần đây, chủ đề về Quantum Machine Learning (hay QML) là một lĩnh vực nghiên cứu mới và đang được chú ý ở các công ty hàng đầu thế giới như &lt;a href=&#34;https://quantum-computing.ibm.com/lab/docs/iql/machine-learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IBM&lt;/a&gt; hay &lt;a href=&#34;https://quantumai.google/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google&lt;/a&gt;. Do đó, ở bài viết này ngoài việc cung cấp cho bạn đọc cái nhìn cụ thể Quantum Machine Learning là gì, mình cũng sẽ giải thích tại sao chúng ta lại cần QML và một vài hướng tiếp cận cụ thể.&lt;/p&gt;
&lt;h2 id=&#34;quantum-machine-learning-là-gì-a-name1a&#34;&gt;Quantum Machine Learning là gì? &lt;a name=&#34;1&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Nếu như ai đã làm quen với các bài toán của Machine Learning hay Deep Learning, các mô hình đang dần được xây dựng lớn hơn và phức tạp hơn để giải quyết các bài toán khó (hard combinatorial optimization problems), nó dẫn tới việc tiêu tốn rất nhiều tài nguyên tính toán (computational resources) trong việc huấn luyện cũng như là vận hành. Một ví dụ điển hình là mô hình &lt;a href=&#34;https://lambdalabs.com/blog/demystifying-gpt-3/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GPT-3&lt;/a&gt; gồm 175 tỷ tham số sẽ cần tốn 355 năm và gần 5 triệu đô nếu train trên một NVIDIA Tesla V100 GPU. Do đó, trên thực tế họ đã train GPT-3 với 1024 A100 GPUs và mất 34 ngày.&lt;/p&gt;
&lt;p&gt;Tuy nhiên, vấn đề đó có thể sẽ được giải quyết với sự xuất hiện của máy tính lượng tử (quantum computer). Máy tính lượng tử được phát triển dựa theo các thuyết của vật lý lượng tử để đưa ra một khả năng tính toán vượt trội so với máy tính truyền thống. Hãy lấy một bài toán tìm kiếm là một ví dụ: giả sử bạn phải tìm 1 quả bóng trong 1 triệu ngăn kéo và câu hỏi là bạn sẽ phải mở qua bao nhiêu ngăn kéo trước khi tìm được quả bóng đó? Đôi khi bạn sẽ may mắn tìm được quả bóng trong chỉ vài lần thử và ngược lại bạn cũng có thể phải mở gần như toàn bộ 1 triệu ngăn kéo kia. Trung bình bạn sẽ cần tới 500,000 lượt để tìm ra quả bóng. Tuy nhiên, với máy tính lượng tử, bạn có thể thực hiện bài toán đó trong vòng 1000 lượt bằng một thuật toán được gọi là &lt;a href=&#34;https://en.wikipedia.org/wiki/Grover%27s_algorithm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Grover&amp;rsquo;s algorithm&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Từ đó sự ra đời của Quantum Machine Learning như một sự giao thoa của các thuật toán trên máy tính lượng tử với mô hình Machine Learning để cải thiện cả về mặt tính toán cũng như độ chính xác (được gọi là &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_supremacy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;quantum advantage&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id=&#34;một-vài-hướng-tiếp-cận-của-quantum-machine-learning-a-name2a&#34;&gt;Một vài hướng tiếp cận của Quantum Machine Learning &lt;a name=&#34;2&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Cho đến này đã có khá nhiều hướng triển khai QML được đề xuất, mặc dù nhiều trong số chúng vẫn chỉ là lý thuyết thuần túy và cần một máy tính lượng tử hoàn chỉnh để thực nghiệm; tuy nhiên, cũng đã có các thuật toán đã được triển khai trên quy mô nhỏ và chứng minh đạt được &amp;lsquo;quantum advantage&amp;rsquo;. Sau đây mình sẽ đề cập tới hai hướng tiệp cận phổ biến của QML.&lt;/p&gt;
&lt;p&gt;a) QRAM-based Quantum Machine Learning&lt;/p&gt;
&lt;p&gt;Tương tự RAM (Random Access Memory) ở các máy tính truyền thống, các nhà nghiên cứu đã giới thiệu một &amp;lsquo;quantum-version&amp;rsquo; của RAM được gọi là &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_memory&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;QRAM&lt;/a&gt; để xử lý vấn đề ghi và đọc thông tin trên máy tính lượng tử. Có thể nói QRAM là một phần rất quan trọng nhiều thuật toán của QML. Thậm chí chúng đạt được &amp;lsquo;quantum advantage&amp;rsquo; là nhờ QRAM.&lt;/p&gt;
&lt;p&gt;Một ứng dụng cụ thể và cũng như được dùng nhiều nhất của QRAM là khả năng cải thiện tốc độ tính toán của tích vô hướng (dot product) hay &lt;a href=&#34;https://en.wikipedia.org/wiki/Kernel_method&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Method&lt;/a&gt; - một phương pháp quen thuộc của Machine Learning mà điển hình là Support Vector Machine (SVM). Với sự can thiệp của QRAM, ta có thể tính tích vô hướng $x^Ty$ với độ phức tạp là $O(logN)$ so với $O(N)$ trên máy tính truyền thống, trong đó $x, y$ là các vectors $N$ chiều.&lt;/p&gt;
&lt;p&gt;Từ đó các thuật toán được ra đời như là &lt;a href=&#34;https://arxiv.org/abs/1401.2142&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum K-Means&lt;/a&gt; dựa vào QRAM để có độ phức tạp $O(log(Nd))$ (so với $O(Nd)$ của thuật toán K-Means), trong đó $N$ là số data và $d$ là số chiều. Hay &lt;a href=&#34;https://arxiv.org/abs/1307.0471&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Support Vector Machine&lt;/a&gt; đạt được độ phức tạp $O(log(Nd))$ so với $O(poly(N,d))$ của thuật toán SVM bình thường, và một số khác: &lt;a href=&#34;https://arxiv.org/abs/1307.0401&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum PCA&lt;/a&gt;, &lt;a href=&#34;https://link.springer.com/article/10.1007/s10994-012-5316-5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum K-Medians&lt;/a&gt;, etc.&lt;/p&gt;
&lt;p&gt;Ở hướng tiếp cận này, các thuật toán sẽ dựa vào khả năng tính toán vượt trội của quantum computing để cải thiện độ phức tạp. Tuy nhiên ở máy tính lượng tử không chỉ có vậy. Thông tin ở đó được biểu diễn dựa theo nguyên lý chồng chập (&lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_superposition&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Superposition&lt;/a&gt;), thay vì được mã hóa rời rạc thành các bits 0 và 1, có nghĩa thông tin có thể tồn tại đồng thời ở bit 0 và bit 1 theo một phân phối nào đó. Do đó, &amp;rsquo;learning space&amp;rsquo; ở máy tính lượng tử sẽ hoàn toàn khác và thậm chí được mở rộng hơn so với máy tính truyền thống. Thực tế đã có nhiều nghiên cứu với mục tiêu khám phá không gian này để cải thiện khả năng học tập (learning capability) của mô hình Machine Learning và hướng tiếp cận sau đây là ví dụ điển hình cho việc này.&lt;/p&gt;
&lt;p&gt;b) Quantum Neural Network.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.google.com/url?sa=i&amp;amp;url=https%3A%2F%2Fwww.researchgate.net%2Ffigure%2FComparison-between-a-classical-neural-networks-and-b-quantum-neural-networks-used-for_fig3_345261288&amp;amp;psig=AOvVaw0GZmtR456ENI7xPiIde2Qb&amp;amp;ust=1664949826824000&amp;amp;source=images&amp;amp;cd=vfe&amp;amp;ved=0CAwQjRxqFwoTCKCo69PzxfoCFQAAAAAdAAAAABAN&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img src=&#34;https://www.researchgate.net/profile/Zhenyu-Cai-3/publication/345261288/figure/fig3/AS:953988396642305@1604459966798/Comparison-between-a-classical-neural-networks-and-b-quantum-neural-networks-used-for.ppm&#34; alt=&#34;Source&#34; loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Được thúc đẩy từ sự thành công của mạng học sâu (classical deep learning), mạng nơ-ron lượng tử (&lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_neural_network&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Neural Network&lt;/a&gt;, hay QNN) cũng mang những nét tương đồng với mạng nơ-ron truyền thống (NN). Chúng được thiết kế theo cấu trúc &lt;a href=&#34;https://en.wikipedia.org/wiki/Feedforward_neural_network&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;feed-forward&lt;/a&gt;, trong đó các layers là các phép biến đổi đơn nhất (&lt;a href=&#34;https://en.wikipedia.org/wiki/Unitary_transformation#:~:text=In%20mathematics%2C%20a%20unitary%20transformation,inner%20product%20after%20the%20transformation.&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;unitary transformation&lt;/a&gt;). Hầu hết cấu trúc của QNN dựa theo &lt;a href=&#34;https://pennylane.ai/qml/glossary/variational_circuit.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Variational Quantum Circuits&lt;/a&gt; hay thường được gọi Parameterised Quantum Circuits. Ở đó các biến đổi trong cấu trúc mạng QNN sẽ phụ thuộc vào tham số $\theta$ (learning parameters) và chúng sẽ thay đổi trong quá trình tối ưu.&lt;/p&gt;
&lt;p&gt;Đến nay, đã có khá nhiều nghiên cứu bắt đầu những bước sơ khai trong việc ứng dụng QNN vào các bài toán mà tạo nên thành công của Deep Learning (image classification, natural language processing): &lt;a href=&#34;https://ieeexplore.ieee.org/document/9574030&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Convolutional Neural Network&lt;/a&gt;, &lt;a href=&#34;https://arxiv.org/abs/2202.11766&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Natural Language Processing&lt;/a&gt;, etc. Mặc dù đã có những chứng minh cho thấy khả năng QNN có thể giúp giảm thiểu số lượng tham số cần phải huấn luyện so với NN trong khi vẫn đạt được độ chính xác tương đương; tuy nhiên, các thí nghiệm vẫn ở trên quy mô nhỏ và các mô hình NN thường bị giới hạn để so sánh. Do đó, QNN vẫn đang là hướng tiếp cận mở và hiện tại vẫn đang thu hút rất nhiều sự chú ý.&lt;/p&gt;
&lt;h2 id=&#34;kết-luận-a-name3a&#34;&gt;Kết luận &lt;a name=&#34;3&#34;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Bài viết này, mình đã chia sẻ qua Quantum Machine Learning là gì và cũng như lý do ta cần suy xét tới chúng. Cuối cùng, mình trình bày qua hai hướng tiếp cận phổ biến của QML: QRAM-based Quantum Machine Learning và Quantum Neural Network. Tuy nhiên, có một vài các hướng khác mọi người có thể xem qua: &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_annealing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum annealing&lt;/a&gt;, &lt;a href=&#34;https://arxiv.org/pdf/0810.3828.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum-enhanced Reinforcement Learning&lt;/a&gt;, etc. Có thể thấy QML tuy là một lĩnh vực mới nhưng đã thu hút rất nhiều nghiên cứu ở nhiều chủ đề khác nhau của Machine Learning. Ở các bài viết tiếp theo, mình sẽ cố gắng trình bày một cách hệ thống để giúp các bạn nắm rõ hơn các kiến thức thú vị này.&lt;/p&gt;
&lt;p&gt;Cảm ơn mọi người đã đọc bài.&lt;/p&gt;
&lt;script src=&#34;https://giscus.app/client.js&#34;
        data-repo=&#34;qmlvietnam/qmlvietnam.github.io&#34;
        data-repo-id=&#34;R_kgDOH833kg&#34;
        data-category=&#34;General&#34;
        data-category-id=&#34;DIC_kwDOH833ks4CRwGU&#34;
        data-mapping=&#34;pathname&#34;
        data-strict=&#34;0&#34;
        data-reactions-enabled=&#34;1&#34;
        data-emit-metadata=&#34;0&#34;
        data-input-position=&#34;bottom&#34;
        data-theme=&#34;light_high_contrast&#34;
        data-lang=&#34;vi&#34;
        crossorigin=&#34;anonymous&#34;
        async&gt;
&lt;/script&gt;&lt;blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>QML Vietnam</title>
      <link>https://example.com/authors/intro/</link>
      <pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://example.com/authors/intro/</guid>
      <description>&lt;p&gt;Chào mọi người, cảm ơn mọi người ghé qua trang blog của mình.&lt;/p&gt;
&lt;p&gt;Mình là &lt;a href=&#34;https://scholar.google.com/citations?hl=vi&amp;amp;user=l1wJ4C8AAAAJ&amp;amp;authuser=2&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Nguyễn Quang Tuyến&lt;/a&gt;, Ph.D. student tại &lt;a href=&#34;https://www.uts.edu.au/research/centre-quantum-software-and-information&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Centre for Quantum Software and Information&lt;/a&gt; (QSI) của trường đại học công nghệ Sydney (University of Technology Sydney). Mình tốt nghiệp đại học ngành Khoa học máy tính tại trường University of Aizu, Nhật Bản. Trong thời gian làm đồ án tốt nghiệp liên quan đến &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_machine_learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Quantum Machine Learning&lt;/a&gt; (mình tạm dịch là Học Máy Lượng Tử), mình đã có mong muốn làm ra một blog cá nhân viết về lĩnh vực này. Do đó, dựa theo hai nguồn cảm hứng từ trang &lt;a href=&#34;https://machinelearningcoban.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Machine Learning cơ bản&lt;/a&gt; của anh Vũ Hữu Tiệp và &lt;a href=&#34;https://nttuan8.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Deep Learning cơ bản&lt;/a&gt; của anh Tuấn, mình tạo trang này với hai kỳ vọng. Một là giúp mình tổng hợp kiến thức về Quantum Machine Learning cũng giúp mình nắm chắc nền móng trong giai đoạn sơ khai của lĩnh vực này. Hai là chia sẻ cũng như mong muốn tạo được một cộng đồng các bạn đọc Việt Nam tiếp cận tới một lĩnh vực mới nhưng cũng đầy triển vọng này.&lt;/p&gt;
&lt;p&gt;Trong quá trình chuẩn bị cũng như là viết bài, mình sẽ cố gắng ít động chạm tới các hiện tượng vĩ mô ở trong thế giới lượng tử và mình sẽ đi từ góc nhìn của một computer scientist chứ không phải là một physicist. Nhưng mình hi vọng mọi người đã làm quen qua các kiến thức cơ bản của Đại Số Tuyến Tính (vì hầu hết các biến đổi trong máy tính lượng tử là tuyến tính) và kỹ năng lập trình Python (nếu có thể mình sẽ cố đưa ra các code demo sau các bài viết để giúp mọi người hiểu rõ được vấn đề hơn).&lt;/p&gt;
&lt;p&gt;Ngoài các bài viết ở trên &lt;a href=&#34;#posts&#34;&gt;Blogs&lt;/a&gt;, &lt;a href=&#34;#newsletter&#34;&gt;Newsletter&lt;/a&gt; là nơi mình cập nhật những thông tin mới nhất hàng tháng liên quan tới Quantum Machine Learning (các bài báo mới, hội nghị, workshop, etc.)&lt;/p&gt;
&lt;p&gt;Mình vui lòng tiếp nhận mọi ý kiến thảo luận của mọi người qua email &lt;a href=&#34;mailto:quantummachinelearning.vietnam@gmail.com&#34;&gt;quantummachinelearning.vietnam@gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mình xin chân thành cảm ơn.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>https://example.com/admin/config.yml</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://example.com/admin/config.yml</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
